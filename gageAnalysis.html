<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <script type="text/javascript" src="https://code.jquery.com/jquery-latest.js"></script>
    <script src="https://code.highcharts.com/highcharts.js"></script>
    <script src="https://code.highcharts.com/modules/heatmap.js"></script>
    <script src="https://code.highcharts.com/highcharts-more.js"></script>
    <script src="https://code.highcharts.com/modules/exporting.js"></script>
    <script src="https://highcharts.github.io/export-csv/export-csv.js"></script>
    <script src="https://code.jquery.com/ui/1.11.4/jquery-ui.js"></script>
    <script src="https://www.weather.gov/source/aprfc/js/jquery.ui.slider.custom.js"></script>
    <link rel="stylesheet" href="https://code.jquery.com/ui/1.12.1/themes/base/jquery-ui.css">
    <script src="https://www.weather.gov/source/aprfc/js/draggable-points.js"></script>


    <script src="https://www.openlayers.org/api/OpenLayers.js"></script>
    <script src="https://www.weather.gov/source/aprfc/js/moment.js"></script>
    <script src="https://www.weather.gov/source/aprfc/js/clipboard.js"></script>
    <script src="https://www.weather.gov/source/aprfc/js/xmlToJSON.min.js"></script>
    <script src="USGS_CODE.js"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/openlayers/4.0.1/ol.js"></script>
    <script src="https://cdn.jsdelivr.net/jstat/latest/jstat.min.js"></script>
    <script src="https://www.weather.gov/source/aprfc/js/spearson.js"></script>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-83585603-1', 'auto');
      ga('send', 'pageview');

    </script>

    <style type="text/css">
        .success {
            color: #228B22;
        }
        .map {
          height: 400px;
          width: 500px;
        }
        #heatMapQ,
        #annualMapQ{
            float:left;
        }
        .box-table-a{font-family:"Lucida Sans Unicode", "Lucida Grande", Sans-Serif;font-size:12px;width:480px;text-align:left;border-collapse:collapse;margin:20px;}.box-table-a th{font-size:13px;font-weight:normal;background:#b9c9fe;border-top:4px solid #aabcfe;border-bottom:1px solid #fff;color:#039;padding:8px;}.box-table-a td{background:#e8edff;border-bottom:1px solid #fff;color:#669;border-top:1px solid transparent;padding:8px;}.box-table-a tr:hover td{background:#d0dafd;color:#339;}

	.ui-slider .ui-slider-handle{
    		width:10px;
	}


    </style>

    <link rel="stylesheet" href="https://openlayers.org/en/v3.19.0/css/ol.css" type="text/css">


    <title>NWS Gage Analysis</title>


    <h1>NWS Gage Analysis</h1>
    <table>
        <tr>
            <td>
                Data Ingest Log:
                <div id="log" style="overflow-y: scroll;width:300px; height:300px; font-size:x-small;"><br></div>
            </td>
            <td>
                <span>Gage location (circle) and NWM reach shown (blue highlight)
                <div id="map" class="map" class="ui-widget-content"></div>
                <input type="button" id="nwmUp" class = "hasNWM" value="NWM Upstream Results">
                <input type="button" id="nwmDown" class = "hasNWM" value="NWM Downstream Results">
            </td>
            <td align="center">
                <div id='usgsSiteInfo'></div>
                 <div id="annualPeakGraph" style="width: 500px; height: 225px; margin: 0 auto;"></div>
                 <div id="MannKendallResults"></div>
                 <div id="spearmanResults"></div>

        </tr>
    </table>
<hr>

    <table>
        <tr>
            <td>
                Graph Options:
                <input type="checkbox" id="dischargeAxis" style="padding-left:20px" >Log Scale&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                Flood Frequency:<input type="checkbox" id="addFFlinesStation" style="padding-left:20px" checked>Station
                <input type="checkbox" id="addFFlinesWeighted" style="padding-left:20px"  >Weighted<br>
                Graph Functions:
                <input type="radio" name="Qfunction" value = "base" checked>Base Flow Calc
                <input type="radio" name="Qfunction" value = "shift">Shift Data<br>
                USGS Data:  <input type="checkbox" id ="getDv"> Daily
                <input type="checkbox" id="getIv" checked> Instantaneous<br>
                Start Date:<input type="text" id="dischargeStart" length=10>
                End Date:<input type="text" id="dischargeEnd" length=10>
                <input type="button" id="loadQ" value="Load Custom Range"> <!-- or <input type="button" id="loadAnnual" value="Current Year"> --></br>
                Comparison:<input type="text" id="comparisonSite" length=20>
                <input type="button" id="loadComparison" value="Load Comparison Site or Year"></br>
                <input type="button" id="zoomToStage" value="Quick Zoom">
                <input type="button" id="getGDLhydro" value="Plot Peak Flow Hydrograph">
                <div id="dischargegraph" style="width: 800px; height: 500px; padding-left:20px"></div>
            </td>
            <td>
                <input type="checkbox" id="ratingLog" style="padding-left:20px" >Log Scale
                <input type="checkbox" id="showFloodStagesRating" checked>Show Flood Stages&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                Highlight measurements based on:
                <input type="radio" name="markerHighlights" value = "age" checked>Age
                <input type="radio" name="markerHighlights" value = "quality">Quality<br><br>
                <div style="float:left;"><label for="months2show">Plot QMeas Between:</label>
                <input type="text" id="months2show" readonly style="border:0;padding:4px; color:#f6931f; font-size: 14px; font-weight:bold;">
                <div id="qmeas-range"  style="width: 200px;"></div></div>
                <div style="float:left;"><label for="years2show">Plot QMeas Between:</label>
                <input type="text" id="years2show" readonly style="border:0;padding:4px; color:#f6931f; font-size: 14px; font-weight:bold;">
                <div id="qmeas-years"  style="width: 200px;"></div></div>
                <div id="ratinggraph" style="width: 800px; height: 550px; margin: 0 auto"></div>
            </td>
        </tr>
        <tr>
            <td>
                Drag Box:<input type="radio" name="stageDrag" value="zoom" checked>Zoom
                <input type="radio" name="stageDrag" value="missing" >Set Missing</br>
                <input type="checkbox" id="showFloodStages" checked>Show Flood Stages<br>
                <input type="button" id="shefEncodeForecast" value="Shef Encode Forecast">
                <input type="button" id="shefEncodeObserved" value="Shef Encode Missing Obs">
                <div id="stagegraph" style="width: 800px; height: 550px; margin: 0 auto"></div>
                <button class="btn" data-clipboard-target="#shefText">Copy shef to Clipboard</button>
                <div id='shefText'></div>
            </td>
            <td style="vertical-align: top;">
                <div id="heatMapQ" style="width: 600px; height: 550px; margin: 0 auto;"></div>
                <div id="annualMapQ" style="width: 75px; height: 550px; margin: 0 auto;"></div>
            </td>
        </tr>

    </table>
<hr>


<script type="text/javascript">



///////////////////////////////////
//  Set up Thumbnail Map for USGS gage location and NWM Reach
///////////////////////////////////

if (ol.Map.prototype.getLayer === undefined) {
    ol.Map.prototype.getLayer = function (id) {
        var layer;
        this.getLayers().forEach(function (lyr) {
            if (id == lyr.get('id')) {
                layer = lyr;
            }
        });
        return layer;
    }
}


var osm_default = new ol.layer.Tile({
      source: new ol.source.XYZ({
        url: 'https://txpub.usgs.gov/arcgis/rest/services/Mapping/HydroBaseMapForTerrain/MapServer/tile/{z}/{y}/{x}'
      })
    });

var osm_default2 = new ol.layer.Tile({
      source: new ol.source.XYZ({
        url: 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Terrain_Base/MapServer/tile/{z}/{y}/{x}'
      })
    });



var vectorSource = new ol.source.Vector({
    format: new ol.format.GML3(),
    url: function(extent) {
        return 'https://idpgis.ncep.noaa.gov/arcgis/services/NWS_Observations/ahps_riv_gauges/MapServer/WFSServer?'+
            'service=WFS&version=1.1.0&request=GetFeature&typeName=Observed_River_Stages&srsname=EPSG:3857&'+
            'bbox=' + extent.join(',') + ',EPSG:3857';
        },
    strategy: ol.loadingstrategy.bbox,
    projection: 'EPSG:3857'
});


var vector = new ol.layer.Vector({
    source: vectorSource,
    style: new ol.style.Style({
        stroke: new ol.style.Stroke({
            color: 'rgba(0, 0, 255, 1.0)',
            width: 10
        })
    })
});


var map = new ol.Map({
    layers: [osm_default2,osm_default],
    //layers: [vector],
    target: 'map',
    view: new ol.View({
        center: ol.proj.transform([-100, 40], 'EPSG:4326', 'EPSG:3857'),
        zoom: 10
    })
});

var mousePosition = new ol.control.ScaleLine({
    units: 'us',
    minWidth: 100
});

map.addControl(mousePosition);





var AHPSjson = {};    //GLOBAL AHPS JSON DATA BY SITE  AHPSjson[nwslid];
var USGSjson = {};    //GLOBAL USGS JSON DATA BY SITE
new Clipboard('.btn');
var CROSSWALKTABLE;
var AJAXLOOKUPTABLE = [
                {
                match:"crossWalk.json",
                name:"USGS-NWS CrossWalk Table",
                },
                {
                match:"\/nwis\/site",
                name: "USGS Site Information"
                },
                {
                match:"rdbajax.php.+rating",
                name: "USGS Rating Curve"
                },
                {
                match:"hydrograph_to_xml.php",
                name: "NWS AHPS Data"
                },
                {
                match:"get_ahps_data.php.+rss",
                name: "AHPS RSS Data"
                },
                {
                match:"rdbajax.php.+annualPeaks",
                name: "USGS Annual Peaks"
                },
                {
                match:"rdbajax.php.+qmeas",
                name: "USGS Discharge Measurements"
                },
                {
                match:"\/nwis\/stat",
                name: "USGS Statistics"
                },
                {
                match:"\/nwis\/iv.+00060",
                name: "USGS Inst. Discharge Data"
                },
                {
                match:'\/nwis\/dv.+00060',
                name: "USGS Daily Discharge Data"
                },
                {
                match:'\/nwis\/iv.+00065',
                name: "USGS Inst. Stage Data"
                },
                {
                match:'forecasts\/short_range',
                name: "NWM Short Range"
                },
                {
                match:'forecasts\/medium_range',
                name: "NWM Medium Range"
                },
                {
                match:'forecasts\/long_range',
                name: "NWM Long Range"
                }]

$( document ).ajaxSuccess(function( event, xhr, settings ) {
        for(i=0;i<AJAXLOOKUPTABLE.length;i++){
            var regExp = new RegExp(AJAXLOOKUPTABLE[i].match);
            if(regExp.test(settings.url)){
                 $( "#"+settings.url.replace(/\W/g, '')).html( '<span style="color:green" id="'+AJAXLOOKUPTABLE[i].name.replace(/\s+/g, '')+'_log">Success</span>');
             }
         }
});

$( document ).ajaxError(function( event, xhr, settings,thrownError ) {
        for(i=0;i<AJAXLOOKUPTABLE.length;i++){
            var regExp = new RegExp(AJAXLOOKUPTABLE[i].match);
            if(regExp.test(settings.url)){
                 $( "#"+settings.url.replace(/\W/g, '')).html( '<span style="color:red" id="'+AJAXLOOKUPTABLE[i].name.replace(/\s+/g, '')+'_log">Error (<i>'+thrownError+'</i>)</span>' );
             }
         }
});

$( document ).ajaxSend(function( event, xhr, settings ) {
        for(i=0;i<AJAXLOOKUPTABLE.length;i++){
            var regExp = new RegExp(AJAXLOOKUPTABLE[i].match);
            if(regExp.test(settings.url)){
                $( '<span style="color:red" id="'+settings.url.replace(/\W/g, '')+'">Loading....</span> ' +  AJAXLOOKUPTABLE[i].name + " <a href='"+settings.url+"' target='_blank'>Data Link</a><br>" ).prependTo( "#log" );

             }
         }
});


String.prototype.capitalize = function() {
    return this.charAt(0).toUpperCase() + this.slice(1);
}
function round(num, places) {
    var multiplier = Math.pow(10, places);
    return Math.round(num * multiplier) / multiplier;
}


function addReach2Map(map,reach){
     var styles = {
        'LineString': new ol.style.Style({
          stroke: new ol.style.Stroke({
            color: 'blue',
            width: 3
          })
        })
       };

       var styleFunction = function(feature) {
        return styles[feature.getGeometry().getType()];
      };

    var geojsonObjects = {
        'type': 'FeatureCollection',
        'crs': {
            'type': 'name',
            'properties': {
                'name': 'EPSG:3857'
            }
        },
        'features': [ {
            'type': 'Feature',
            'geometry': {
                'type': 'LineString',
                'coordinates': reach
            }
        }]
    };
    var geojsonObject = {
        'crs': {
            'type': 'name',
            'properties': {
                'name': 'EPSG:3857'
            }
        },
        'type': 'Feature',
        'geometry': {
            'type': 'LineString',
            'coordinates': reach
        }
    };


    map.removeLayer(map.getLayer('NWMreach'));
    var reachFeature = new ol.format.GeoJSON().readFeature(geojsonObject);

    var vectorSource = new ol.source.Vector({
        features: [reachFeature]
    });

    var vectorLayer = new ol.layer.Vector({
        source: vectorSource,
        style: styleFunction,
        id: 'NWMreach'
    });
    map.addLayer(vectorLayer);
}



function showUSGSinfo(jsonData){
    var html = "<table class = \"box-table-a\"><thead><tr><th colspan = \"2\">USGS Site Information</th></tr>";
    html = html + "<tr><td>USGS Site Name</td><td>"+jsonData.station_nm+"</td></tr>";
    html = html + "<tr><td>USGS Site Number</td><td>"+jsonData.site_no+"</td></tr>";
    html = html + "<tr><td>Drainage Area</td><td>"+jsonData.drain_area_va+" sq. mi.</td></tr>";
    html = html + "<tr><td>USGS Gage Datum</td><td>"+jsonData.alt_va+" ft ("+jsonData.alt_datum_cd+")</br>"+USGS_alt_meth_cd[jsonData.alt_meth_cd]+" (+- "+jsonData.alt_acy_va+" ft)</td></tr>";
    $('#usgsSiteInfo').html(html);
}

///////////////////////////////////
//  shef Encode Data
///////////////////////////////////

function shefEncode(dataSet,onlyMissing){
    if (onlyMissing === undefined) {
        onlyMissing = false;
    }

    var nwsLid = dataSet.options.NWSid;
    var data = dataSet.data;

    var pedts = dataSet.options.pedts;

    var shefData = '';
    for(i=0;i<data.length-1;i++){
        var shefMessage = '';

        if(typeof data[i] == 'undefined') continue;

        var date = moment.utc(data[i].x).format("YYMMDD");
        var time = moment.utc(data[i].x).format("HHmm");
        var dc = moment.utc().format('YYMMDDHHmm');

        if(onlyMissing && (data[i].y == null)){
            shefMessage = '.AR ' + nwsLid.toUpperCase() +' '+date+' Z DH'+time+'/DC'+dc+'/'+pedts+' -9999\n';
        }
        else if(!onlyMissing){
            shefMessage = '.AR ' + nwsLid.toUpperCase() +' '+date+' Z DH'+time+'/DC'+dc+'/'+pedts+' '+data[i].y.toFixed(2)+'\n';
        }
        shefData = shefData + shefMessage;
    }
    return shefData;
}


///////////////////////////////////
//  Linear Interpolation
///////////////////////////////////

function lineInterpolate( point1, point2,XorY,value){
  var result = new Object();
  if(XorY == 'x'){
  result.y = value;
  ratio = (value-point1.y)/(point2.y-point1.y);
  result.x = Math.round(point1.x+ratio*(point2.x-point1.x));
  }
  if(XorY == 'y'){
  result.x = value;
  ratio = (value-point1.x)/(point2.x-point1.x);
  result.y = Math.round(point1.y+ratio*(point2.y-point1.y));
  }
  return result;
}

///////////////////////////////////
//  Calculate area under the curve
///////////////////////////////////

function volumeUnderCurve(flowData,xMin,xMax){
    if (xMin === undefined) {
        xMin = 0;
    }
    if (xMax === undefined) {
        xMax = 0;
    }

    if((xMin==0)&&(xMax==0)){
        xMin = flowData.xData[0];
        xMax = flowData.xData[flowData.xData.length-1];
    }
    if(xMin>xMax){
        var temp = xMin;
        xMin = xMax;
        xMax = temp;
    }
    var volume = 0;
    var volArray = [];
    for(i=0;i<flowData.data.length;i++){
        if(typeof flowData.data[i] == 'undefined') continue;
        if((flowData.data[i].x <= xMin) && (flowData.data[i+1].x > xMin)){
            point = lineInterpolate(flowData.data[i],flowData.data[i+1],'y',xMin);
            volArray.push(point);
        }
        if((flowData.data[i].x > xMin) && (flowData.data[i].x <= xMax)){
            volArray.push(flowData.data[i]);
        }
        if((flowData.data[i].x < xMax) && (flowData.data[i+1].x > xMax)){
            point = lineInterpolate(flowData.data[i],flowData.data[i+1],'y',xMax);
            volArray.push(point);
        }
    }
    for(i=0;i<volArray.length-1;i++){
        volume += ((volArray[i].y+volArray[i+1].y)/2)*((volArray[i+1].x-volArray[i].x)/1000);
        }
    acreFeet = volume/43560;
    return acreFeet;
}

function getPeakInfo(flowData,xMin,xMax){
if (xMin === undefined) {
        xMin = 0;
    }
    if (xMax === undefined) {
        xMax = 0;
    }

    if((xMin==0)&&(xMax==0)){
        xMin = flowData.xData[0];
        xMax = flowData.xData[flowData.xData.length-1];
    }
    if(xMin>xMax){
        var temp = xMin;
        xMin = xMax;
        xMax = temp;
    }
    var peak ={
         value : 0,
         date : ''};
    for(i=0;i<flowData.data.length;i++){
        if(typeof flowData.data[i] == 'undefined') continue;
        if((flowData.data[i].x <= xMax) && (flowData.data[i+1].x > xMin)){
            if(flowData.data[i].y > peak.value){
                peak.value = flowData.data[i].y;
                peak.date = flowData.data[i].x;
            }
        }
    }
    return peak;
}

function sensSlope(x,y){

    var n = x.length;
    var sensSlopeArray = []

    for(i=0;i<n;i++){

        for(j=i+1;j<n;j++){
            var slope = (y[j]-y[i])/(x[j]-x[i]);
            sensSlopeArray.push(slope);

        }
    }

    return jStat.median(sensSlopeArray);
}

function mkS(dataArray){
    //Results verified against the 'R' package for sites WLWA2 and MHBC1

    var S = 0;
    var result = {};
    var end = dataArray.length-4;
    dataArray = dataArray.slice(0, end);

    var n = dataArray.length;
    var revArray = dataArray.reverse();
    for(i=0;i<n;i++){

        for(j=i+1;j<n;j++){
            if(revArray[i]>revArray[j]) S = S +1;
            if(revArray[i]<revArray[j]) S = S -1;

        }
    }

    var varS = (n*(n-1)*(2*n+5))/18;
    var Z = 0;
    if(S<0){
        Z = (S+1)/(Math.sqrt(varS));
    }
    else if(S>0){
        Z =  (S-1)/(Math.sqrt(varS));
    }
    var tau = S/(n*(n-1)/2)
    p = jStat.ztest(Z,2);
    result = {
        'n' : n,
        'S' : S,
        'varS' : varS,
        'tau' : tau.toFixed(3),
        'Z': Z,
        'p' : p.toFixed(3),
    }
    var summary = "<strong>Mann-Kendal Trend Test:</strong> Tau "+result.tau+" <i>p</i> "+result.p;
    if(result.p <0.05){
        if(Z>0){
            summary = summary + " Significant increasing trend detected at 0.05";
        }
        else{
            summary = summary + " Significant decreasing trend detected at 0.05";
        }
    }
    else{
        summary = summary + ' No trend detected';
    }
    $('#MannKendallResults').html(summary);
    return result;
}


function handleBaseFlow(chart,series,xMin,xMax){
    if (xMin === undefined) {
        xMin = 0;
    }
    if (xMax === undefined) {
        xMax = 0;
    }
    if(chart.get('baseFlow')){
        $(".baseFlowLabel").remove();
    }
    var baseFlow = chart.get('baseFlow');
    if((xMin+xMax) == 0){
        xMin = baseFlow.data[0].x;
        xMax = baseFlow.data[baseFlow.data.length-1].x;
    }
    var startDate = Highcharts.dateFormat('%l %P %b %e', xMin);
    var endDate = Highcharts.dateFormat('%l %P %b %e', xMax);
    var totalVolume = volumeUnderCurve(series,xMin,xMax);
    var baseVolume = volumeUnderCurve(chart.get('baseFlow'));
    var peak = getPeakInfo(series,xMin,xMax);
    var baseVolumeIn = baseVolume/(Area*640)*12;
    var totalVolumeIn =totalVolume/(Area*640)*12;
    var qIncrease = peak.value - baseFlow.data[0].y;
    //series = chart.get('baseFlow');
    var slope = (baseFlow.data[1].y-baseFlow.data[0].y)/((baseFlow.data[1].x-baseFlow.data[0].x)/1000)*3600*24;
    var len = ((xMax-xMin)/1000)/(3600*24);
    var diff = (baseFlow.data[baseFlow.data.length-1].y-baseFlow.data[0].y);

    labelText = '<br>Total  Volume: '+totalVolumeIn.toFixed(2)+'in   '+totalVolume.toFixed(0)+' ac-ft<br>'+'Baseflow Volume: '+baseVolumeIn.toFixed(2)+'in   '+baseVolume.toFixed(0)+' ac-ft<br>Peak Vol: '+(totalVolumeIn-baseVolumeIn).toFixed(2)+'in   '+(totalVolume-baseVolume).toFixed(2)+' ac-ft<br>Slope: '+Math.round(slope)+' cfs change per day<br>Start: '+startDate+'<br>Peak: '+Highcharts.dateFormat('%l %P %b %e', peak.date)+'<br>End: '+endDate+'<br>Duration: '+len.toFixed(1)+'days<br>Q increase: '+qIncrease+' cfs<br>Delta: '+Math.round(diff)+' cfs'
    textBox = chart.renderer.label(labelText, 10, 80)
    .attr({
            fill: 'rgba(255, 255, 255,1)',
            padding: 8,
            r: 5,
            zIndex: 100,
            class: 'baseFlowLabel',
            'stroke-width':2,
            stroke: 'black'
         })
         .add();
    removeBox = chart.renderer.label('<center>Click to<br> Remove</center>', 10, 40)
        .attr({
            fill: 'rgba(255, 255, 255,1)',
            padding: 1,
            zIndex: 100,
            class: 'baseFlowLabel',
            'stroke-width':2,
            r:5,
            stroke: 'black'
         })
         .on('click', function () {
            textBox.destroy();
            removeBox.destroy();
            if(chart.get('baseFlow')) chart.get('baseFlow').remove();
            if(chart.get('peakHydroGraph')) chart.get('peakHydroGraph').remove();
         })
        .add();
}

///////////////////////////////////
//  Add straight line base flow to graph
///////////////////////////////////

function addBaseFlowSeries(chart,flowData,xMin,xMax){
    var volArray = [];
    var pt1;
    var pt2;
    for(var i=0;i<flowData.data.length-1;i++){
        if(typeof flowData.data[i] == 'undefined') continue;
        if((flowData.data[i].x <= xMin) && (flowData.data[i+1].x > xMin)){
           pt1   = lineInterpolate(flowData.data[i],flowData.data[i+1],'y',xMin);
        }
        if((flowData.data[i].x <= xMax) && (flowData.data[i+1].x > xMax)){
           pt2 = lineInterpolate(flowData.data[i],flowData.data[i+1],'y',xMax);
        }
    }

    for(var z=0;z<=9;z++){
        var newX = xMin+(((xMax-xMin)/9)*z);
        var newY = pt1.y+(((pt2.y-pt1.y)/9)*z);
        var tempPt;
        for(var i=0;i<flowData.data.length-1;i++){
            if(typeof flowData.data[i] == 'undefined') continue;

            if((flowData.data[i].x <= newX) && (flowData.data[i+1].x > newX)){
                var tempPt = lineInterpolate(flowData.data[i],flowData.data[i+1],'y',newX);
                if(tempPt.y<newY){
                    tempPt.y = Math.floor(tempPt.y);
                    volArray.push(tempPt);
                }else{
                    volArray.push([newX,Math.floor(newY)]);
                }
            }
        }
    }
    newSeries ={
        type: "area",
        data: volArray,
        name:'Base Flow',
        color: 'grey',
        fillColor: 'rgba(200,200,200,0.5)',
        id: 'baseFlow',
        draggableY: true,
        peakDataId:flowData.options.id,
        zIndex:4,
        draggableX: true,
        dataGrouping: {
             	enabled: false
        },
        point: {
            events: {
                drop: function(){
                    this.y = Math.floor(this.y);
                    handleBaseFlow(chart,flowData);

                }
            }
        }
    };
    chart.addSeries(newSeries);
    return;
}


function simple_moving_averager(period) {
    var nums = [];
    return function(num) {
        nums.push(num);
        if (nums.length > period)
            nums.splice(0,1);  // remove the first element of the array

        var sum = 0;
        for (var i in nums)
            sum += nums[i];
        var n = period;
        if (nums.length < period)
            n = nums.length;
        return(sum/n);
    }
}


function getPeakHydroGraph(chart,curve,baseflow,interval){
    var period = 12;
    var sma = simple_moving_averager(period);
    var newsma = 0;
    var oldsma = 0;
    if (interval === undefined) {
        interval = 1;
    }
    var newData = [];

    var x = baseflow.data[0]['x'];
    var y = parseInt(curveLookup(curve.data,x));
    var endX = parseInt(baseflow.data[baseflow.data.length-1]['x']);
    newData.push([x,0]);
    var workingTime = moment(x).minutes(0).add(interval,'hours');
    var peakTime = workingTime;
    while(parseInt(workingTime.format('x')) < endX){
        y = curveLookup(curve.data,workingTime)-curveLookup(baseflow.data,workingTime);
        newsma = sma(parseInt(y));
        if(newsma > oldsma){
            oldsma = newsma;
            peakTime = workingTime.clone();
            peakTime.add(-(period/2),'hours');
        }
        //console.log(y,oldsma,newsma,peakTime.format());
        var val = parseInt(y);
        if(val < 0) val =0;
        newData.push([parseInt(workingTime.format('x')),parseInt(y)]);
        workingTime.add(interval,'hours');
    }
    newData.push([endX,0]);

    newSeries ={
        data: newData,
        name:'Event Hydrograph',
        color: 'red',

        id: 'peakHydroGraph',

        zIndex:4,
    };
    chart.addSeries(newSeries);

    var alignDate = moment("2000-06-01");
    var startDate = moment("2000-05-01");
    var shift = Math.round(moment.duration(peakTime.diff(moment(x))).asHours());
    var hours = moment.duration(alignDate.diff(moment("2000-05-01"))).asHours();
    var data = [];
    for(var i = 0; i < (hours-shift) ; i++){
        data.push([startDate.format('MM/DD/YY HH:mm'),"",0]);
        startDate.add(1,'hours');
    }
    for(var i=0;i<newData.length;i++){
        data.push([startDate.format('MM/DD/YY HH:mm'),moment(newData[i][0]).format('MM/DD/YY HH:mm'),newData[i][1]]);
        startDate.add(1,'hours');
    }
    var html = '';
    for(var i =0;i<data.length;i++){
        html = html+data[i][0]+","+data[i][1]+","+data[i][2]+"<br />";
    }
    $('#shefText').html(html);


}








function getParameterByName(name, url) {
        if (!url) url = window.location.href;
        name = name.replace(/[\[\]]/g, "\\$&");
        var regex = new RegExp("[?&]" + name + "(=([^&#]*)|&|#|$)"),
            results = regex.exec(url);
        if (!results) return null;
        if (!results[2]) return '';
        return decodeURIComponent(results[2].replace(/\+/g, " "));
}


function showQmeas(lowMonth,highMonth,lowYear,highYear,chartDiv){
    if (chartDiv === undefined) {
        chartDiv = 'ratinggraph';
    }
    var chart = $('#'+chartDiv).highcharts();

    var series = chart.get('qMeasured');
    var newData = [];

    $.each(series.userOptions.originalData,function(){
        var month = parseInt(moment(this.date).format("M"));
        var year =  parseInt(moment(this.date).format("Y"));
        if((month>=lowMonth) && (month<=highMonth)){
            if((year>=lowYear) && (year<=highYear)){
                newData.push(this);

             }
        }
    });
     chart.get('qMeasured').setData(newData);
}


///////////////////////////////////
//  Load National Water Model Results
///////////////////////////////////



function addNWM(chartDiv,lat,lon,forecastType,dir,reachID){
    if (reachID === undefined) {
        reachID = 0;
    }
    var point2 = {};

    if(lat > 90){
        point2.lat = lat;
        point2.lon = lon;
    }
    else{
        var esriProj = new OpenLayers.Projection("EPSG:3857");
        var wgs84 = new OpenLayers.Projection("EPSG:4326");
        var point = new OpenLayers.LonLat(lon, lat);
        point2 =  point.transform(wgs84, esriProj);
    }
    var ht = 315*100;     //imageDisplay x 100 = each pixel 100 meters
    var wd = 1370*100;    //imageDisplay x 100 = each pixel 100 meters


    var params = {
        tolerance : 1,
        returnGeometry : true,
        geometryType : 'esriGeometryPoint',
        mapExtent : (point2.lon-wd)+','+(point2.lat-ht)+','+(point2.lon+wd)+','+(point2.lat+ht),
        imageDisplay : '1370,315,1',
        f : 'json',
        sr : 102100,
        layers: 'top',
        geometry: '{ "x" : '+point2.lon+', "y" : '+point2.lat+' }'
    };


    if(reachID == 0){
         $.ajax({
                type: "GET",
                url: "https://mapservice.nohrsc.noaa.gov/arcgis/rest/services/national_water_model/flowlines/Mapserver/identify",
                data: params,
                async: false,
                contentType: "application/json; charset=utf-8",
                headers : {'Content-Type' : 'application/x-www-form-urlencoded; charset=UTF-8'},
                dataType: "json",
                success: function (data) {
                    if (data.results.length == 0) {
                        $( '<span style="color:orange">No NWM reach found('+lat+','+lon+')<br></span>' ).prependTo( "#log" );
                   }
                    var stream = data.results[0];
                    $.each( data.results, function( key, value ) {
                        if(value.attributes.streamorder > stream.attributes.streamorder){
                            stream = value;
                        }
                        if(value.attributes.streamorder == stream.attributes.streamorder){
                            if(value.attributes.linkdim > stream.attributes.linkdim && dir == 'down'){
                                stream = value;
                            }
                            if(value.attributes.linkdim < stream.attributes.linkdim && dir == 'up'){
                                stream = value;
                            }
                        }
                    });
                    if(typeof stream == 'undefined') return false;
                    reachID = stream.attributes.reach_id;
                    if(forecastType == 'short_range'){
                        addReach2Map(map,stream.geometry.paths[0]);
                    };
                    plotNWM(chartDiv,reachID,forecastType,stream);
                },
                error: function (request, status, errorThrown) {
                    console.log(status);
                }
        });
     }
     else{
        plotNWM(chartDiv,reachID,forecastType);
     }
    return reachID;
}


function plotNWM(chartDiv,reachID,forecastType,stream){
    var chartAdd = $('#'+chartDiv).highcharts();

    if (forecastType === undefined) {
        forecastType = 'short_range';
    }
    var typeName = forecastType.split("_");

    var zVal,seriesColor;
    switch (forecastType) {
    case 'short_range':
        seriesColor = "red";
        zVal = 5;
        break;
    case 'medium_range':
        seriesColor = "blue";
        zVal = 4;
        break;
    case 'long_range':
        seriesColor = "orange";
        zVal = 3;
        break;
    }
    var params = {station_id:reachID};
    var series = {data: [],
                  param: 'discharge',
                  id: "NWM"+typeName[0],
                  color:seriesColor,
                  calcVol: true,
                  zIndex:zVal,
                  nwmJSON:stream,
                  source: 'NWS-NWM',};
    $.ajax({
            type: "GET",
            url: "https://nwmdata.nohrsc.noaa.gov/0.2/forecasts/"+forecastType+"/streamflow",
            data: params,
            contentType: "application/json; charset=utf-8",
            headers : {'Content-Type' : 'application/x-www-form-urlencoded; charset=UTF-8'},
            dataType: "json",
            success: function (forecast) {
                series.name = "NWM "+typeName[0]+" term issued:"+forecast[0]["valid-time"];
                $.each( forecast[0].data, function( key,point ) {
                    xVal = parseInt(moment.utc(point["forecast-time"]).format("x"));
                    series.data.push([xVal,Math.round(point.value)]);
                })
                if(series) chartAdd.addSeries(series);

            },
            error: function (request, status, errorThrown) {
                console.log(status);
                return false;
            }
        });

    return;

}

function addNWM2Stage(dischargeGraph,stageGraph){
    var NWMseries = ['NWMshort','NWMmedium','NWMlong'];
    var stagePlt = $(stageGraph).highcharts();
    var ratingchart = $('#ratinggraph').highcharts();
    var dischargePlt = $(dischargeGraph).highcharts();
    if(stagePlt.get('NWMoutput')) stagePlt.get('NWMoutput').remove();

    var rCurve;
    if(typeof(ratingchart.get('curve')) != 'undefined'){
        rCurve = ratingchart.get('curve');
    }
    else if(typeof(ratingchart.get('nwsCurve')) != 'undefined'){
        rCurve = ratingchart.get('nwsCurve');
    }
    else {
        console.log("Can't add nwm to stage chart");
        return;
    }
    if(typeof(dischargePlt.get("NWMshort")) == 'undefined') return;

    stagePlt.addSeries({data:null,name:'NWM Output',id:'NWMoutput'});
    $.each( NWMseries, function( index, item ) {

        var oldSeries = dischargePlt.get(item);


        if(stagePlt.get(item)){
            stagePlt.get(item).remove();
        }
        var newSeries = {data: [],
                  param: 'stage',
                  name: oldSeries.name,
                  linkedTo: ':previous',
                  showInLegend: false,
                  id: item,
                  color:oldSeries.color,
                  zIndex:oldSeries.zIndex,
                  source: 'NWS-NWM',};

        for(var y =0; y< oldSeries.data.length;y++){
            var stage = curveLookup(rCurve.data,parseInt(oldSeries.data[y].y));
            newSeries.data.push([oldSeries.data[y].x,parseFloat(stage)]);
        }
        stagePlt.addSeries(newSeries);
    });

}






function addAnnualData(chartDiv,dv_iv,year,site){
    var chartAdd = $('#'+chartDiv).highcharts();
    var usgsID;
    var nwsID;

    if (year === undefined) {
        xMin = 'all';
    }
    if (site === undefined) {
        usgsID = chartAdd.options.usgsID;
        nwsID = chartAdd.options.nwsLid;
    }
    else{
        usgsID = site.usgs;
        nwsID = site.nws;
    }

    if(usgsID === undefined) return;

    var ext = chartAdd.xAxis[0].getExtremes();
    var graphYear = moment((ext.max+ext.min)/2).format("YYYY");
    var cD = '00060';
    var seriesId = 'USGSiv'+usgsID;
    var start = '1900-01-01';
    var end = '2020-01-01';
    if(year != 'all'){
        start = year+'-01-01';
        end = year+'-12-31';
    }

    var usgsUrl = "https://nwis.waterservices.usgs.gov/nwis/iv/?format=json&sites="+usgsID+"&parameterCd="+cD+"&startDT="+start+"&endDT="+end;
    var durLabel = 'Instantaneous';
    var lineColor = 'royalblue';
    var lineIndex = 2;
    if(dv_iv == 'dv'){
        durLabel = 'Daily';
        lineColor = 'darkgreen';
        seriesId = 'USGSdv'+usgsID;
        lineIndex = 3;
        usgsUrl = "https://waterservices.usgs.gov/nwis/dv/?format=json&sites="+usgsID+"&parameterCd="+cD+"&startDT="+start+"&endDT="+end;
    };

    $.ajax({
        url: usgsUrl,
        dataType: 'json',
        username: "USGS Real Time",
        xhrFields: {
            custom: "custom Field"
        },
        timeout: 20000, // sets timeout to 3 seconds
        success: function(json){
            if(json.value.timeSeries.length>0){
                var allData = USGStoHC(json,"00060");
                var workingYear = moment(allData[Math.round(allData.length/2)][0]).format("YYYY");
                var yearData = [];
                var origDate = [];
                var olddate = 0;
                var years = graphYear - workingYear;
                for(var i=0;i<allData.length;i++){
                    var date = moment.utc(allData[i][0]).year(graphYear);
                    origDate.push(allData[i][0]);
                    if(date.valueOf() > olddate){
                        yearData.push([date.valueOf(),allData[i][1]]);
                        olddate = date.valueOf();
                    }

                }

                newSeries ={
                    data: yearData,
                    name: nwsID.toUpperCase()+' '+workingYear+'-'+dv_iv,
                    param: 'stage',
                    source: 'USGS',
                    timeShift: true,
                    id: seriesId+'_'+workingYear,
                    zIndex:3,
                    calcVol: true,
                    USGSid:usgsID,
                    originalDates:origDate,
                    tooltip: {
                        headerFormat:'<b>{point.x:%Y-%m-%d}</b><br>',
                        pointFormatter: function (){
                            if(this.series.options.dateShift == 0){
                                return '<b>'+numberWithCommas(this.y) + ' cfs</b>';
                            }else{
                                return '<b>'+numberWithCommas(this.y) + ' cfs</b><br>(Orig. Date: '+moment(this.series.options.originalDates[this.index]).format("YYYY-MM-DD H:mm")+')' ;
                            }
                        },
                    },

                };
                chartAdd.addSeries(newSeries);
                }
            }

    })

}


function addUSGS(chartDiv,type,dv_iv,site){
    var chartAdd = $('#'+chartDiv).highcharts();
    var usgsID;
    var nwsID;

    if (type === undefined) {
        type = 'discharge';
    }
    if (site === undefined) {
        usgsID = chartAdd.options.usgsID;
        nwsID = chartAdd.options.nwsLid;
    }
    else{
        usgsID = site.usgs;
        nwsID = site.nws;
    }

    //if(usgsID === undefined) return;
    if(typeof(usgsID) == 'undefined'){
        $( '<span style="color:orange">USGS '+dv_iv+' data (no id)<br></span>' ).prependTo( "#log" );
        return false;
    }


    var style = 'solid';

    var extX = chartAdd.xAxis[0].getExtremes();
    var cD = '00060';
    var unit = 'cfs';
    var seriesId = 'USGSiv'+usgsID;
    if(type == 'stage') {
        cD = '00065';
        unit = 'ft';
    }
    var newSeries;
    var start = Highcharts.dateFormat('%Y-%m-%d',extX.min-3600*1000*24);
    var end = Highcharts.dateFormat('%Y-%m-%d',extX.max);

    usgsUrl = "https://nwis.waterservices.usgs.gov/nwis/iv/?format=json&sites="+usgsID+"&parameterCd="+cD+"&startDT="+start+"&endDT="+end;
    var durLabel = 'USGS Inst.';
    var lineColor = 'royalblue';
    var lineIndex = 2;
    if(dv_iv == 'dv'){
        durLabel = 'USGS Daily';
        //lineColor = 'darkgreen';
        seriesId = 'USGSdv'+usgsID;
        lineIndex = 3;
        usgsUrl = "https://waterservices.usgs.gov/nwis/dv/?format=json&sites="+usgsID+"&parameterCd="+cD+"&startDT="+start+"&endDT="+end;
    }
    if(style == 'dashed')lineColor = '';
    $.ajax({
        url: usgsUrl,
        dataType: 'json',
        timeout: 20000, // sets timeout to 3 seconds
        success: function(json){
            if(json.value.timeSeries.length>0){
                newSeries ={
                    data: USGStoHC(json,"00060"),
                    name: nwsID.toUpperCase()+' '+durLabel,
                    zIndex:lineIndex,
                    //color: lineColor,
                    dashStyle:style,
                    qual: 'Observed',
                    id: seriesId,
                    param: 'stage',
                    source: 'USGS',
                    calcVol: true,
                    USGSid:usgsID,

                };
                chartAdd.addSeries(newSeries);
            }
        },
    })

}


function addUSGSrating(chartDiv,usgsSite){
     if(typeof(usgsSite) == 'undefined'){
             $( '<span style="color:orange">USGS rating data (no id)<br></span>' ).prependTo( "#log" );
             return;
      }
    var chartAdd = $('#'+chartDiv).highcharts();
    var ratingArray=[];
    $.ajax({
        url: "http://www.data.chenabasin.org/nws/streamGraph/rdbajax.php?site="+usgsSite+"&type=rating",
        dataType: 'json',
        data: '',
        success: function(json){
            if(json.error_info.error == 0){
                ratingArray = ratingJSON2HC(json);

                if(ratingArray.data.length == 0) {
                    var url = 'https://waterdata.usgs.gov/nwisweb/get_ratings?file_type=exsa&site_no='+usgsSite+'&format=rdb';
                    $( '<span style="color:orange">USGS no rating data <a href="'+url+'">Link</a><br></span>' ).prependTo( "#log" );
                    return;
                }
                chartAdd.addSeries(ratingArray);
                addMeasureQ_Rating(chartDiv,usgsSite,"curve");
                chartAdd.yAxis[0].setExtremes(ratingArray['data'][0][1],ratingArray['data'][ratingArray['data'].length-1][1]);
                chartAdd.showResetZoom();

            }
        },
    });
}


function addAHPSrating(chartDiv,nwsLid){
    var chartAdd = $('#'+chartDiv).highcharts();
    var ratingArray=[];

    if(getAhps(nwsLid,AHPSjson) == false) return;

    var hasZero = false;
    if(typeof AHPSjson[nwsLid].rating.datum != 'undefined'){
        $.each(AHPSjson[nwsLid].rating.datum, function(){
            var mult = 1;
            if(this._flowUnits == "kcfs") mult = 1000;
            var flow = parseFloat(this._flow) * mult;
            if(flow < 0.1) return true;

            var stage = parseFloat(this._stage);
            if(stage < 0.1) return true;
            if(flow) ratingArray.push([flow,stage]);
        });
    }

    var newSeries = [{
        data : ratingArray,
        name : 'NWS Rating Curve',
        color: 'purple',
        source: 'NWS',
        id:'nwsCurve',
        NWSid: nwsLid,
        zIndex:3,
    }];
    if(ratingArray.length == 0) return;
    $.each(newSeries, function(){
        chartAdd.addSeries(this);
    });

    return;
}


function getAhps(site,AHPS){
    var data;
    var result;
    if (typeof AHPS[site] === 'undefined') {
        $.ajax({
            //url: "http://www.data.chenabasin.org/nws/streamGraph/get_ahps_data.php?format=json&site="+site,
            url: "https://water.weather.gov/ahps2/hydrograph_to_xml.php?output=xml&gage="+site,
            dataType: 'xml',
            data: data,
            async: false,
            success: function(data){
                xmlString = (new XMLSerializer()).serializeToString(data);
                var x2js = new X2JS();
                var jsonObj = x2js.xml_str2json( xmlString );
                AHPS[site] = jsonObj.site;
                result = true;
                },
            error: function(){
                    result = false;
                }
        })
    }else{
        result = true;
    }
    return result;
}


function addAHPS(chartDiv,type){
    if (type === undefined) {
        type = 'discharge';
    }

    var chartAdd = $('#'+chartDiv).highcharts();
    var nwsLid = chartAdd.options.nwsLid;
    var issued= '';
    var newSeries=[];

    var tzoffset = -1000*(new Date().getTimezoneOffset());

    //Load AHPS data if it is not already loaded
    if(getAhps(nwsLid,AHPSjson) == true){
        issued =  Highcharts.dateFormat('%l %P %b %e',(new Date(AHPSjson[nwsLid].forecast._issued).getTime())+tzoffset);
     }
     else{
        issued = 'No forecast';
     }

    if(chartAdd.title.textStr == 'test') chartAdd.setTitle({ text: AHPSjson[nwsLid]._name});

    var stageArray = [];
    var dischargeArray = [];

    if(typeof AHPSjson[nwsLid].forecast.datum != 'undefined'){

            $.each(AHPSjson[nwsLid].forecast.datum, function(){
                var mult = 1;
                var d = new Date(this.valid.__text).getTime();
                stageArray.push([parseInt(d),parseFloat(this.primary.__text)]);
                if(typeof this.secondary != 'undefined'){
                    if(this.secondary._units == 'kcfs') mult = 1000;
                    if(this.secondary.__text > 0){
                        dischargeArray.push([parseInt(d),parseFloat(this.secondary.__text)*mult]);
                    }
                }
            });
            newSeries.push({
                data : stageArray,
                name : 'NWS Forecast ( Issued: '+issued+' )',
                color: 'purple',
                qual: 'Forecast',
                param: 'stage',
                pedts: AHPSjson[nwsLid].forecast.datum[0].pedts,
                source: 'NWS',
                draggableY: true,
                id:'nwsStageForecast',
                NWSid: nwsLid,
                zIndex:3,
            });

            if(dischargeArray.length>0){
                newSeries.push({
                    data : dischargeArray,
                    name : 'NWS Forecast( Issued: '+issued+' )',
                    color: 'purple',
                    qual: 'Forecast',
                    param: 'discharge',
                    id:'nwsDischargeForecast',
                    calcVol: true,
                    draggableY: true,
                    source: 'NWS',
                    NWSid: nwsLid,
                    zIndex:3,
                });
            }
        }


    var stageArray = [];
    var dischargeArray = [];
    if(typeof AHPSjson[nwsLid].observed.datum != 'undefined'){
        $.each(AHPSjson[nwsLid].observed.datum, function(){
            var mult = 1;
            var d = new Date(this.valid.__text).getTime();
            stageArray.push([parseInt(d),parseFloat(this.primary.__text)]);
            if(typeof this.secondary != 'undefined'){
                if(this.secondary._units == 'kcfs') mult = 1000;
                if(this.secondary.__text > 0){
                    dischargeArray.push([parseInt(d),parseFloat(this.secondary.__text)*mult]);
                }
            }

        });

        newSeries.push({
            data : stageArray.sort(),
            name : 'NWS Observed',
            color: 'green',
            qual: 'Observed',
            param: 'stage',
            pedts: AHPSjson[nwsLid].observed.datum[0].pedts,
            draggableY: true,
            dateShift:0,
            source: 'NWS',
            NWSid: nwsLid,
            id: 'nwsStageObserved',
            zIndex:3,
        });

        if(dischargeArray.length>0){
            newSeries.push({
                data : dischargeArray.sort(),
                name : 'NWS Observed',
                color: 'green',
                qual: 'Observed',
                param: 'discharge',
                dateShift: 0,
                calcVol: true,
                id: 'nwsDischargeObserved',
                source: 'NWS',
                NWSid: nwsLid,
                zIndex:3,
            });
        }
    }

    $.each(newSeries, function(){
        if(this.param == type){
            chartAdd.addSeries(this);
        }
    });
}


function addMeasureQ_Rating(chartDiv,usgsID,type,marker){
    if (marker === undefined) {
        marker = 'age';
    }
    var chart = $('#'+chartDiv).highcharts();
    if(usgsID == null){
        usgsID = chart.options.usgsID;
    }



    if(typeof(usgsID) == 'undefined'){
        $( '<span style="color:orange">USGS measured Q (no id)<br></span>' ).prependTo( "#log" );
        return false;
    }
    $.ajax({
        url: "http://www.data.chenabasin.org/nws/streamGraph/rdbajax.php?site="+usgsID+"&type=qmeas&rand="+Math.floor((Math.random() * 100000) + 1),
        dataType: 'json',
        data: '',
        success: function(json){
            var newSeries = qMeasJSON2HC_Rating(json,type,marker);
            if(json.error_info.error == 0){
                newSeries[0].turboThreshold = 2000;
                chart.addSeries(newSeries[0]);
                var htmlText = '<span style="color:red">Most Recent Measurement</span><br><span style="color:orange">Measurements in the Last Year</span><br><span style="color:rgba(0,0,205,0.8)">Newer -</span><span style="color:rgba(0,0,205,0.3)"> Older Measurements</span>';

                if(marker == 'quality'){
                    htmlText = '<span style="color:Green">Excellent - Good</span><br><span style="color:#E7F317">Fair</span><br><span style="color:orange")">Poor</span>';
                }
                if(chartDiv == 'ratinggraph'){
                    text = chart.renderer.text(
                        htmlText,
                        550,
                        400
                    ).attr({
                        zIndex: 5,
                        class: 'Qnotes'
                    }).css({
                        color: 'black',
                        'text-align': 'center',
                        'font-weight': 'bold',
                        width:  400,
                        fontSize: '13px'
                    }).add();
                    box = text.getBBox();
                    chart.renderer.rect(box.x - 5, box.y - 5, box.width + 10, box.height + 10, 5)
                        .attr({
                            fill: 'white',
                            stroke: 'gray',
                            class: 'Qnotes',
                            'stroke-width': 1,
                            zIndex: 4
                        })
                        .add();
                    var minYear = 2100;
                    var maxYear = 1900;
                    $.each(newSeries[0]['data'], function( index, value ) {
                        if(parseInt(moment(value.date).format('Y'))< minYear) minYear = parseInt(moment(value.date).format('Y'));
                        if(parseInt(moment(value.date).format('Y'))> maxYear) maxYear = parseInt(moment(value.date).format('Y'));
                    });
                    $( "#qmeas-years" ).dragslider({
                        range: true,
                        min: parseInt(minYear),
                        max: parseInt(maxYear),
                        rangeDrag: true, // Enable range dragging.
                        step: 1,
                        values: [parseInt(minYear),parseInt(maxYear)],
                        slide: function( event, ui ) {
                            $( "#years2show" ).val(ui.values[0]+ " - " +ui.values[1]);
                            showQmeas($("#qmeas-range").dragslider("values",0),$("#qmeas-range").dragslider("values",1),ui.values[0],ui.values[1]);
                        },
                        stop: function( event, ui ) {
                            $( "#years2show" ).val(ui.values[0]+ " - " +ui.values[1]);
                            showQmeas($("#qmeas-range").dragslider("values",0),$("#qmeas-range").dragslider("values",1),ui.values[0],ui.values[1]);
                        }
                    });
                    $( "#years2show" ).val($("#qmeas-years" ).dragslider( "values", 0 ) +
                       " - " + $("#qmeas-years" ).dragslider( "values", 1 ));
                }
            }
        }
    });


}

function addUSGSFF(chartDiv,type){
    if(type == null){
        type = 'wtd';
    }
    halign = 'left';
    style = 'solid';


    var chart = $('#'+chartDiv).highcharts();
    var usgsID = chart.options.usgsID;
    var url = "http://www.data.chenabasin.org/nws/streamGraph/get_peak_flow.php?site="+usgsID;
    $.ajax({

        url: url,
        dataType: 'json',
        data: '',
        beforeSend: function(json){
            $( '<span id="'+url.replace(/\W/g, '')+'"><span style="color:red">Loading....</span> USGS Flood Freq. Info:  <a href="'+url+'" target="_blank">Data Link</a></span><br>').prependTo( "#log" );
       },
        success: function(json){
            $( "#"+url.replace(/\W/g, '')).html( '<span style="color:green">Success </span><span>USGS Flood Freq. Info: <a href="https://streamstatsags.cr.usgs.gov/gagepages/html/'+usgsID+'.htm" target="_blank">Source Data</a></span><br>');

            chart.yAxis[0].addPlotLine({
                value: json[type+'2'],
                color: 'green',
                width:2,
                id: 'ffline'+type,
                dashStyle: style,
                zIndex:2,
                label:{
                    align: halign,
                    text: '2 Yr ('+type+')'
                }
            });
            chart.yAxis[0].addPlotLine({
                value: json[type+'5'],
                color: 'yellow',
                width:2,
                id: 'ffline'+type,
                dashStyle: style,
                zIndex:2,
                label:{
                    align: halign,
                    text: '5 Yr ('+type+')'
                }
            });
            chart.yAxis[0].addPlotLine({
                value: json[type+'10'],
                color: 'orange',
                width:2,
                zIndex:2,
                id: 'ffline'+type,
                dashStyle: style,
                label:{
                    align: halign,
                    text: '10 Yr ('+type+')'
                }
            });
            chart.yAxis[0].addPlotLine({
                value: json[type+'25'],
                color: 'red',
                width:2,
                zIndex:2,
                id: 'ffline'+type,
                dashStyle: style,
                label:{
                    align: halign,
                    text: '25 Yr ('+type+')'
                }
            });
            chart.yAxis[0].addPlotLine({
                value: json[type+'50'],
                color: 'cyan',
                width:2,
                zIndex:2,
                id: 'ffline'+type,
                dashStyle: style,
                label:{
                    align: halign,
                    text: '50 Yr ('+type+')'
                }
            });
            chart.yAxis[0].addPlotLine({
                value: json[type+'100'],
                color: 'blue',
                width:2,
                zIndex:2,
                id: 'ffline'+type,
                dashStyle: style,
                label:{
                    align: halign,
                    text: '100 Yr ('+type+')'
                }
            });
            chart.yAxis[0].addPlotLine({
                value: json[type+'200'],
                color: 'tan',
                width:2,
                zIndex:2,
                id: 'ffline'+type,
                dashStyle: style,
                label:{
                    align: halign,
                    text: '200 Yr ('+type+')'
                }
            });
          },
          error: function(json){
            $( "#"+url.replace(/\W/g, '')).html( '<span style="color:red">Error </span><span>USGS Flood Freq. Info: <a href="https://streamstatsags.cr.usgs.gov/gagepages/html/'+usgsID+'.htm" target="_blank">Source Data</a></span><br>');
        }
    });

}



function addAnnualPeaks(chartDiv,usgsID){
    var chart = $('#'+chartDiv).highcharts();

    if(usgsID == null){
        usgsID = chart.options.usgsID;
    }

    if(typeof(usgsID) == 'undefined'){
        $( '<span style="color:orange">USGS Annual peaks (no id)<br></span>' ).prependTo( "#log" );
        return false;
    }
    $.ajax({
        url: "http://www.data.chenabasin.org/nws/streamGraph/rdbajax.php?site="+usgsID+"&type=annualPeaks",
        dataType: 'json',
        success: function(data){
        var chart = $('#'+chartDiv).highcharts();
        var year = new Date().getFullYear();
        var peakSeries = [
            {
                name: 'Annual Peaks',
                tooltip: {
                    headerFormat:'<b>Peak Annual Flow<br>{point.x:%b %e %Y}</b><br>',
                    pointFormatter: function (){
                        return '<b>' +numberWithCommas(this.y) + ' cfs</b>';
                    },
                },
                states: {
                    hover: {
                        enabled: false
                    }
                },
                data:[],
                visible: true,
                lineWidth: 0,
                type: 'scatter',
                zIndex:15,
                calcVol: false,
                id:'annualPeaks',
                color: 'orange',
                dataLabels: {
                    enabled: true,
                    format: '{point.x:%Y-%m-%d}<br>{point.y} cfs',
                    y: -3,
                    style:{
                         "fontSize": "9px",
                    },
                },
                marker : {
                    enabled : true,
                    radius : 4
                },
                showInLegend:true
            },
            {
                name: 'Annual Peaks',
                tooltip: {
                    headerFormat: 'Peak Annual Flow<br>',
                    pointFormatter: function (){
                        return '<b>' +this.peakDate+': '+numberWithCommas(this.y) + ' cfs</b>';
                    },
                },
                states: {
                    hover: {
                        enabled: false
                    }
                },
                data:[],
                type: 'scatter',
                visible: true,
                id:'annualPeakYear',
                calcVol: false,
                lineWidth: 0,
                padding:0,
                point:{
                    events:{
                        click: function(){
                            addAnnualData(chartDiv,'iv',this.year);
                            addAnnualData(chartDiv,'dv',this.year);
                        }
                     }
                 },
                dataLabels: {
                    enabled: true,
                    format: '{point.year}',
                    y: -3,
                    style:{
                         "fontSize": "9px",
                    },
                },
                zIndex:15,
                color: 'black',
                marker : {
                    enabled : true,
                    radius : 4
                },
                showInLegend:true
            }];

        var d = new Date()
        var n = d.getTimezoneOffset()/60;
        var peaks = [];
        var years = [];
        var begin = '1800-1-1';
        var end = '2100-1-1';
        if(typeof data.records == 'undefined') return false;
        $.each(data.records,function(){
            var newD = this[2].split('-');
            var d = moment(this[2]);
            d.add(12+n,'hours');
            var point = [d,this[4]];
            peakSeries[0].data.push([parseInt(d.format('x')),this[4]]);
            peaks.push(this[4]);
            d.add(3,'months');
            years.push(moment(d).format('YYYY'));
            d= Date.UTC(year,newD[1]-1,newD[2],12+n);
            point = {x:d,
                     y:this[4],
                     peakDate:this[2],
                     year:newD[0]
                     }
            peakSeries[1].data.push(point);
          });

        chart.addSeries(peakSeries[0]);
        chart.addSeries(peakSeries[1]);
        checkTrends(peakSeries[1],begin,end);


        }
    })
}


function checkTrends(series,begin,end){

    var peakChart = $('#annualPeakGraph').highcharts();
    series.color = 'black';
    series.marker.symbol = 'diamond';
    series.dataLabels.enabled = false;

    var peaks = [];
    var years = [];
    var startTime = moment(begin,"YYYY-MM-DD");
    var endTime = moment(end,"YYYY-MM-DD");

    $.each(series.data,function(){
        var curDate = moment(this.peakDate,"YYYY-MM-DD");
        this.x = parseInt(curDate.format("x"));
        if((curDate > startTime) & (curDate < endTime)){
            peaks.push(this.y);
            years.push(this.year);
        }
    });

    csvContent = peaks.join(',');
    csvContent = years.join(',');
    peakChart.addSeries(series);
    var mkSresult = mkS(peaks);

    var corr = spearson.correlation.spearman(years, peaks,true).toFixed(3);
    var sslope = sensSlope(years,peaks);
    var string = "";
    for(i=0;i<years.length;i++){
        string= string+years[i]+",";
    }
    string = "";
    for(i=0;i<years.length;i++){
        string= string+peaks[i]+",";
    }
    t = corr*(Math.sqrt((years.length-2)/(1-corr*corr)));
    //console.log(t);

    var pval = jStat.ttest(t,years.length).toFixed(4);
    //console.log(pval);
    var summary = "<strong>Spearman Trend Test:</strong>";
    if(pval <0.05){
        if(sslope>0){
            summary = summary + " Significant increasing trend detected at 0.05";
        }
        else{
            summary = summary + " Significant decreasing trend detected at 0.05";
        }
    }
    else{
        summary = summary + " No trend detected"
    }
    $('#spearmanResults').html(summary);
}



function addStats(chartDiv){
    var chartAdd = $('#'+chartDiv).highcharts();
    var usgsID = chartAdd.options.usgsID;

    if(usgsID === undefined) return;

    $.get('https://waterservices.usgs.gov/nwis/stat/?format=rdb,1.0&indent=on&sites='+usgsID+'&statReportType=daily&statTypeCd=all&parameterCd=00060', function( data ) {
//https://waterservices.usgs.gov/nwis/stat/?format=rdb&sites=11335000&statReportType=daily&statTypeCd=all

        var lines = data.split('\n');
        var statsSeries = [
            {
                name: 'Daily Statistics',
                data: [],
                visible : true,
                id: 'dailyStats',
                type: 'arearange',
                lineWidth: 0,
                color: '#0000FF',
                calcVol: false,
                zIndex: 0,
                showInLegend:true,
                fillOpacity: 0.2,
                point:{
                    events:{
                        //mouseOver: null,
                        click: function(){
                            addAnnualData(chartDiv,'iv',this.maxYear);
                            addAnnualData(chartDiv,'dv',this.maxYear);
                        }
                     }
                 },
                tooltip:{
                    headerFormat:'<b>{point.x:%b %e}</b><br>',
                    pointFormatter: function (){
                        return '<b>Max: '+numberWithCommas(this.high) + ' cfs ('+this.maxYear+')<br><b>90%: '+numberWithCommas(this.low) + ' cfs<br>Count: '+this.count+'</b>';
                    },
                }
            },
            {
                name: 'P 0% -  10%',
                data: [],
                visible : true,
                trackByArea: true,
                type: 'arearange',
                calcVol: false,
                lineWidth: 0,
                linkedTo: ':previous',
                color: '#8B0000',
                fillOpacity: 0.2,
                zIndex: 0,
                tooltip:{
                    headerFormat:'<b>{point.x:%b %e}</b><br>',
                    pointFormatter: function (){
                        return '<b>10%: '+numberWithCommas(this.high) + ' cfs<br><b>Min: '+numberWithCommas(this.low) + ' cfs  ('+this.minYear+')<br>Count: '+this.count+'</b>';
                    },
                },
                point:{
                    events:{
                        mouseOver: null
                    }
                }
           },
            {
                name: 'P 10% -  25%',
                data: [],
                visible : true,
                trackByArea: true,
                type: 'arearange',
                calcVol: false,
                lineWidth: 0,
                linkedTo: ':previous',
                color: '#B8860B',
                fillOpacity: 0.2,
                zIndex: 0,
                tooltip:{
                    headerFormat:'<b>{point.x:%b %e}</b><br>',
                },
                point:{
                    events:{
                        mouseOver: null
                    }
                }
           },
            {
                name: 'P 25% - 75%',
                data: [],
                visible : true,
                trackByArea: true,
                type: 'arearange',
                calcVol: false,
                lineWidth: 0,
                linkedTo: ':previous',
                color: '#006400',
                fillOpacity: 0.3,
                zIndex: 0,
                tooltip:{
                    headerFormat:'<b>{point.x:%b %e}</b><br>',
                },
                point:{
                    events:{
                        mouseOver: null
                    }
                }
            },
            {
                name: 'P 75% - 90%',
                data: [],
                visible : true,
                trackByArea: true,
                type: 'arearange',
                calcVol: false,
                lineWidth: 0,
                linkedTo: ':previous',
                color: '#008B8B',
                fillOpacity: 0.3,
                zIndex: 0,
                tooltip:{
                    headerFormat:'<b>{point.x:%b %e}</b><br>',
                },
                point:{
                    events:{
                        mouseOver: null
                    }
                }
            },
            {
                name: 'P 50% (median)',
                linkedTo: ':previous',
                color: '#D1D0CE',
                data: [],
                zIndex: 2,
                tooltip:{
                    headerFormat:'<b>{point.x:%b %e}</b><br>',
                }
            }
        ];
        var annualSeries =[
            {
                data:[]
             },
            {
                data:[]
             },
            {
                data:[]
             },
            {
                data:[]
             },
             {
                data:[]
             },
            {
                data:[]
             }
             ];





        $.each(lines, function(){
        if (this.substring(0, 4) == "USGS") {
            var tdata = this.split('\t');

            for(i=0;i<tdata.length;i++){
                if(parseInt(tdata[i]) == 0 ) tdata[i]= 1;
                if(parseInt(tdata[i]) > 0 ) tdata[i]= parseInt(tdata[i]);
                if(tdata[i].length == 0) tdata[i] = null;
            }

            var vdate = moment("2016-"+tdata[5]+"-"+tdata[6],"YYYY-MM-DD");
            var doy = vdate.format('MDD');
            //console.log(doy);

            var yearMin = (tdata[12] < 0 ) ? null: tdata[12];
            var yearMax = (tdata[10] < 0 ) ? null: tdata[10];
            var min = (tdata[13] < 0 ) ? null: tdata[13];
            var per5 = (tdata[14] < 0 ) ? null: tdata[15];
            var per10 = (tdata[14] < 0 ) ? null: tdata[16];
            var per25 = (tdata[15] < 0 ) ? null: tdata[18];
            var median =  (tdata[16] < 0 ) ? null: tdata[19];
            var per75 = (tdata[17] < 0 ) ? null: tdata[20];
            var per90 = (tdata[18] < 0 ) ? null: tdata[22];
            var per95 = (tdata[18] < 0 ) ? null: tdata[23];
            var max = (tdata[11] < 0 ) ? null: tdata[11];



            //Set year of max to calendar year from water year...if month is 10,11,12 subtract 1 year
            if(tdata[5] > 9) yearMax = yearMax-1;

            var maxData = {dayOfYear:doy,y:max,high:max,low:per90,maxYear:yearMax,count:tdata[9]};
            var minData = {dayOfYear:doy,y:per10,high:per10,low:min,minYear:yearMin,count:tdata[9]};


            annualSeries[0].data[doy] = maxData;

            //set min -  10% series
            annualSeries[1].data[doy] = minData;
            //set 10% -  25% series
            annualSeries[2].data[doy] = [per10,per25];
            //set 25% - 75% series
            annualSeries[3].data[doy] = [per25,per75];
            //set 75 - 90% series
            annualSeries[4].data[doy] = [per75,per90];
            //set median
            annualSeries[5].data[doy] = [median];
           //set max-min



        }

        });

        var extX = chartAdd.xAxis[0].getExtremes();

        var sdate = moment(extX.min).hours(12);
        var edate = moment(extX.max).hours(12);
        //Make annual stats series match the time period of graph
        while (sdate <= edate){
            var doy = sdate.format("MDD");

            //Push max and min data into series
            var dat = annualSeries[0].data[doy];
            if(typeof dat !== 'undefined'){
                var mData = {
                    dayOfYear:doy,
                    y:dat['y'],
                    x:parseInt(sdate.format("x")),
                    high:dat['high'],
                    low:dat['low'],
                    maxYear:dat['maxYear'],
                    count:dat['count']};

                statsSeries[0].data.push(mData);
            }
          //Push max and min data into series
            var dat = annualSeries[1].data[doy];
            if(typeof dat !== 'undefined'){
                var mData = {
                    dayOfYear:doy,
                    y:dat['y'],
                    x:parseInt(sdate.format("x")),
                    high:dat['high'],
                    low:dat['low'],
                    minYear:dat['minYear'],
                    count:dat['count']};

                statsSeries[1].data.push(mData);
            }

            for(var j=2;j<=5;j++){
                dat = annualSeries[j].data[doy];
                if(typeof dat !== 'undefined'){

                    if(dat.length ==2){
                        statsSeries[j].data.push([parseInt(sdate.format("x")),dat[0],dat[1]]);
                     }else{
                        statsSeries[j].data.push([parseInt(sdate.format("x")),dat[0]]);
                     }
                }
            }
        sdate.add(1, 'days');
        }

       $.each(statsSeries,function(){
            this.marker = { enabled:false};
            if(1){
                chartAdd.addSeries(this);
            }
        });
      });
}



function getRDBSiteInfo(RDB,values){
    var data = { }

    var extractVals = new Array();
    var keys = [];
    var values = [];
    var lines = RDB.split('\n');

    //Iterate through the comment lines of the RDB file
    var j = 0
    for(j = 0;j < lines.length;j++){
      if(lines[j].charAt(0) != '#') break
    }
    var keys = lines[j].split('\t')
    j = j+2

    var values = lines[j].split('\t');

    for (i = 0; i < keys.length; i++) {
       data[keys[i]] = values[i];
    }

    return data
  }


function GetObjectKeyIndex(obj, keyToFind) {
    var i = 0, key;
    for (key in obj) {
        if (key == keyToFind) {
            return i;
        }
        i++;
    }
    return null;
}


function curveLookup(curve,value,type){
    if (type === undefined) {
        type = 'discharge';
    }
    //Assumes rating is [discharge,stage]
    var lowx;
    var highx;
    var lowy;
    var highy;
    var lookupValue;

    if(type == 'discharge'){
        $.each(curve,function(key,val){
            if(typeof(val) == 'undefined') return true;
            if(value == val.x){
                lookupValue = val.y;
                return false;
            }
            if(value < val.x) {
                if(key == 0){
                    lookupValue = val.y;
                    return false;
                }
                highx = val.x;
                highy = val.y;
                lowx = curve[key-1].x;
                lowy =  curve[key-1].y;
                lookupValue = (((value-lowx)/(highx-lowx))*(highy-lowy)+lowy).toFixed(2);
                return false;
            }
        });
    }
    if(type == 'stage'){
        $.each(curve,function(key,val){
            if(typeof(val) == 'undefined') return true;
            if(value == val.y){
                lookupValue = val.x;
                return false;
            }
            if(value < val.y) {
                highx = val.x;
                highy = val.y;
                lowx = curve[key-1].x;
                lowy =  curve[key-1].y;
                lookupValue = (((value - lowy)/(highy-lowy))*(highx-lowx)+lowx).toFixed(0);
                return false;
            }
        });
    }
    return lookupValue;
}

function ratingJSON2HC(json){
    var indepIndex = GetObjectKeyIndex(json.columns,"INDEP");
    var depIndex = GetObjectKeyIndex(json.columns,"DEP");
    var series = {};

    len = json.records.length;

    if(len == 0) return data = null;

    var data = new Array();
    for (var i = 0; i < len; i++) {
        if((json.records[i][indepIndex] > 0)&&(json.records[i][depIndex] > 0))  data.push([json.records[i][depIndex],json.records[i][indepIndex]]);
    }
    series['data'] = data;

    series['name'] = 'USGS Rating Curve';
    series['zIndex'] = 9;
    series['id'] = 'curve',
    series['tooltip']= {
                headerFormat: 'USGS Rating Curve<br>',
                pointFormat: 'Gage Height: {point.y} ft Discharge: {point.x} cfs  </b>'
    };
    return series;
}

function sortFunction(a, b) {
    if (a.x === b.x ){
        return 0;
    }
    else {
        return (a.x < b.x) ? -1 : 1;
    }
}

function sortNinthCol(a, b) {
    if (a[9] === b[9] ){
        return 0;
    }
    else {
        return (a[9] < b[9]) ? -1 : 1;
    }
}

function sortFirstCol(a, b) {
    if (a[0] === b[0] ){
        return 0;
    }
    else {
        return (a[0] < b[0]) ? -1 : 1;
    }
}

function sortDate(a,b) {
  if (a.x < b.x)
    return -1;
  else if (a.x > b.x)
    return 1;
  else
    return 0;
}

function numberWithCommas(x) {
    return x.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
}

function dateFromDay(year, day){
  var date = new Date(year, 0); // initialize a date in `year-01-01`
  return new Date(date.setDate(day)); // add the number of days
}


//Convert USGS measured Q json object to highcharts series (UTC)
//and convert from local to UTC time
function qMeasJSON2HC_Rating(json,type,marker){

    var usgsTZ = {
        'AKST' : 9,
        'AKDT' : 8,
        'MST' : 7,
        'PST' : 8,
        'PDT' : 8,
        'CST' : 6,
        'CDT' : 5,
        'EST' : 5,
        'EDT' : 4
        }


    if (type === undefined) {
         type = 'curve';
    }

    var indepIndex = GetObjectKeyIndex(json.columns,"discharge_va");
    var depIndex = GetObjectKeyIndex(json.columns,"gage_height_va");
    var dtIndex = GetObjectKeyIndex(json.columns,"measurement_dt");
    var tzIndex = GetObjectKeyIndex(json.columns,"tz_cd");
    var qaulIndex = GetObjectKeyIndex(json.columns,"measured_rating_diff");
    var xVal,yVal;
    var series = {
           data: [],
           originalData: [],
           tooltip: {
                headerFormat: 'USGS Measured Discharge<br>',
                pointFormat: '{point.name} <br>Gage Height:{point.gage_height_va} ft<br>Discharge:{point.discharge_va} cfs<br>Quality:{point.measured_rating_diff}<br>Control: {point.control_type_cd}'
            },
            name: 'USGS Measured',
            type: 'scatter',
            zIndex : 10,
            id:'qMeasured',
            color: 'blue',
            marker : {
                enabled : true,
                symbol : 'diamond'
            },
            lineWidth : 0,
            states:{
                hover:{
                    enabled : true,
                    lineWidth:0,
                    lineWidthPlus:0
                }
             }
        }

    if(typeof json.records == 'undefined'){
       return [series];
    }
    len = json.records.length;

    if(len == 0) return data = null;

    for (var i = 0; i < len; i++) {

        //Check if stage is included and if discharge is not zero
        if((json.records[i][depIndex]=== null) && (type == 'curve')) continue;
        if(Math.abs(json.records[i][indepIndex])=== 0) continue;

        var ratingInfo = {}
        var j = 0;
        $.each(json.columns,function(key,value){
            ratingInfo[key] = json.records[i][j];
            j++;
        });

        var qDate = moment.utc(json.records[i][dtIndex]);

        qDate.add(usgsTZ[json.records[i][tzIndex]],'hours');
        var localeDate = moment(json.records[i][dtIndex]);




        if(type == 'curve'){
            xVal = json.records[i][indepIndex];
            yVal = json.records[i][depIndex];
         }else{
            xVal = parseInt(qDate.format("x"));
            yVal = json.records[i][indepIndex];
         }


        age = moment().diff(qDate,'years',true);


        var aColor= 'rgba(0,0,205,0.3)';
        if(age < 10) aColor= 'rgba(0,0,205,0.5)';
        if(age < 5) aColor= 'rgba(0,0,205,0.7)';
        if(age < 1 ) aColor = 'orange';
        if(i+1 == len) aColor = 'red';
        if(type != 'curve') aColor = 'red';

        var quality = json.records[i][qaulIndex];
        qColor = 'gray';
        if(quality.toUpperCase() == 'EXCELLENT') qColor = 'Green';
        if(quality.toUpperCase() == 'GOOD') qColor = '#2ED017';
        if(quality.toUpperCase() == 'FAIR') qColor = '#E7F317';
        if(quality.toUpperCase() == 'POOR') qColor = '#FFA200';
        var mColor = qColor;
        if(marker == 'age'){
            var mColor = aColor;
        }

        ratingInfo = $.extend({
            'x' : xVal,
            'y': yVal,
            'date':parseInt(qDate.format("x")),
            'age':age,
            'color': mColor,
            'aColor':aColor,
            'qColor':qColor,
            'name': localeDate.format('MMMM Do YYYY, h:mm:ss a')+' '+json.records[i][tzIndex],
            'marker':{
                //'fillColor': mColor,
                symbol: 'diamond'
            }
        },ratingInfo);

        series.data.push(ratingInfo);
        series.originalData.push(ratingInfo);

    }

    return [series];
}


//Convert USGS XML object to highcharts data series
function USGStoHC(usgsObj,TSvalue){
    var d = new Date()
    var n = d.getTimezoneOffset();
    var len = usgsObj.value.timeSeries.length;
    if(len == 0) return data = null;
    var urlSource = usgsObj.value.queryInfo.queryURL;
    var isDaily= urlSource.match(/dv/);
    var data = new Array();
    var QRarr = 0;
    for (var i = 0; i < len; i++) {
        if (usgsObj.value.timeSeries[i].variable.variableCode[0].value == TSvalue){
            QRarr = i;
            break;
        }
    }

    var numQ = usgsObj.value.timeSeries[QRarr].values[0].value.length;
    var olddate = moment("1900-01-01");
    for (var i = 0; i < numQ; i++) {
        d = moment.utc(usgsObj.value.timeSeries[QRarr].values[0].value[i].dateTime);
        if(isDaily){
            //Set the time in UTC to noon local (for Alaska subtract 3 hours)
            d.hours(12);
            d.add(n,'minutes');
        }
        val = usgsObj.value.timeSeries[QRarr].values[0].value[i].value;
        val = parseFloat(val);

        if(val < -999) val  = null;
        if(val != null){
            if(val <= 0) val = null;
        }

        if(d > olddate){
            data.push([parseInt(d.format("x")),val]);
            olddate = d;
        }else{
            console.log('backwards'+d.format());

        }

    }

    return data;
}

function USGSDailytoHCHeat(usgsObj,TSvalue){
    len = usgsObj.value.timeSeries.length;
    if(len == 0) return data = null;
    data = new Array()
    QRarr = 0;
    for (var i = 0; i < len; i++) {
      if (usgsObj.value.timeSeries[i].variable.variableCode[0].value == TSvalue){
        QRarr = i;
        break;
      }
    }
    var oldYear = 1800;
    var newYear = 1800;
    var annualSum = 0;
    var numInYear = 0;

    numQ = usgsObj.value.timeSeries[QRarr].values[0].value.length;
    for (var i = 0; i < numQ; i++) {
      var d = new Date(usgsObj.value.timeSeries[QRarr].values[0].value[i].dateTime);
      //Set the hour to noon
      d.setHours(12);
      newYear = d.getFullYear();

      //If it's a new year calculate the average annual (calendar) discharge if more
      //than 330 good values exist
      if(newYear != oldYear){
            if(oldYear != 1800){
                if(numInYear > 330){
                    data.push([parseInt(375),parseInt(oldYear),(annualSum/numInYear)]);
                }
                else{
                    data.push([parseInt(375),parseInt(oldYear),null]);
                }
            }
            oldYear = newYear;
            annualSum = 0;
            numInYear = 1;
      }

      var start = new Date(newYear,0,0);
      var diff = d - start;
      var oneDay = 1000 * 60 * 60 * 24;
      var day = Math.floor(diff / oneDay);
      var val = parseFloat(usgsObj.value.timeSeries[QRarr].values[0].value[i].value);
      if(val < 1) val  = 1;
      data.push([parseInt(day),parseInt(newYear),val])
      annualSum = annualSum + val;
      numInYear = numInYear + 1;
    }
    return data
}


/**
 * Add the NWS flood level bands to the chart
 *
 */
function addNWSBands(graphId,AHPSjson,addTable,type,setTicks){
    //console.log(AHPSjson);


    if (addTable === undefined) {
        addTable = true;
    }
    if (type === undefined) {
        type = 'band';
    }
    if (setTicks === undefined) {
        setTicks = true;
    }

    var chart = $('#'+graphId).highcharts();
    var nwsLid = chart.options.nwsLid;
    if(typeof AHPSjson[nwsLid] == 'undefined') return;
    if(typeof AHPSjson[nwsLid].sigstages == 'undefined') return;

    var extremes = chart.yAxis[0].getExtremes();
    if(getAhps(nwsLid,AHPSjson) == false) return;

    var legW = 550;
    var col1Width = 170;
    var legendy = chart.chartHeight-chart.margin[2]+70;
    var legTextHeight = 10;
    var cellPadding = 1;
    var legendx = 110;
    var upperEnd = 9999;
    var maxY = extremes.dataMax;
    var colors = {
        major : 'rgba(204,51,255,0.7)',
        moderate : 'rgba(255,0,0,0.7)',
        flood : 'rgba(255,153,0,0.7)',
        action : 'rgba(255,255,0,0.7)',
        record: 'rgba(102,178,255,0.7)',
    };
    stage ={
        low : {
            text: 'Low Flow Stage',
            value: extremes.max,
            def:''
        },
        bankfull : {
            text: 'Bankfull Stage',
            value: extremes.max
        },
        action : {
            text: 'Action Stage',
            value: extremes.max,
            def:'A stream, lake or reservoir has risen to a level where you should prepare for possible significant flooding'
        },
        flood : {
            text: 'Flood Stage',
            value: extremes.max,
            def:'Minimal or no property damage, but possibly some public threat'
        },
        moderate : {
            text: 'Moderate Flood Stage',
            value: extremes.max,
            def: 'Some inundation of structures and roads near streams. Some evacuations of people and/or transfer of property to higher elevations are necessary'
        },
        major : {
            text: 'Major Flood Stage',
            value: extremes.max+10,
            def:'Extensive inundation of structures and roads. Significant evacuations of people and/or transfer of property to higher elevations'
        },
        record: {
            text: 'Record Stage',

            def:' Highest stage at a given site during the period of record'
        }
    };

    $.each( colors, function( key, value ){
        if(typeof AHPSjson[nwsLid].sigstages[key].__text != 'undefined'){
            if(parseFloat(AHPSjson[nwsLid].sigstages[key].__text) > maxY){
                maxY = parseInt(AHPSjson[nwsLid].sigstages[key].__text);
            }
            if(key != 'record'){
                //Add flood stage plot band for each flood stage
                if(type == 'band'){
                    chart.yAxis[0].addPlotBand({
                        from: AHPSjson[nwsLid].sigstages[key].__text,
                        to: upperEnd,
                        color: value,
                        id : 'plotBand',
                        zIndex:0
                    })
                }
                //Or just add plot lines for each flood stage
                else{
                    chart.yAxis[0].addPlotLine({
                        value: AHPSjson[nwsLid].sigstages[key].__text,
                        color: value,
                        id : 'plotLine',
                        zIndex:1,
                        width:2,

                    })
                }
                //Add a black contrast line
                chart.yAxis[0].addPlotLine({
                    color: 'black',
                    width: 1,
                    zIndex:6,
                    id: 'plotLine',
                    value: AHPSjson[nwsLid].sigstages[key].__text,
                    label: {
                        text: key.capitalize()+': '+AHPSjson[nwsLid].sigstages[key].__text+' '+AHPSjson[nwsLid].sigstages[key]._units,
                        textAlign: 'left',
                        fontWeight: 'bold',
                        y:-2
                    }
                })
            }
            upperEnd = AHPSjson[nwsLid].sigstages[key].__text

            if(addTable == false) return;


            text = chart.renderer.text(stage[key].text,legendx,legendy)
                .attr({
                    zIndex:6,
                class:'nwsLegend'})
                .css({
                    color: 'black',
                        'text-align': 'center',
                        'font-weight': 'bold',
                        width:  col1Width,
                        fontSize: legTextHeight+'px'
                }).add();
            text = chart.renderer.text(AHPSjson[nwsLid].sigstages[key].__text+' '+AHPSjson[nwsLid].sigstages[key]._units,legendx+col1Width-50,legendy)
                .attr({
                    zIndex:6,
                class:'nwsLegend'})
                .css({
                    color: 'black',
                        'text-align': 'center',
                        'font-weight': 'bold',
                        width:  col1Width,
                        fontSize: legTextHeight+'px'
                }).add();
            text = chart.renderer.text(stage[key].def,legendx+col1Width,legendy)
                .attr({
                    zIndex:6,
                    class:'nwsLegend'})
                .css({
                    color: 'black',
                    'text-align': 'center',
                    width:  legW-col1Width,
                    fontSize: legTextHeight+'px'
                }).add();
            chart.renderer.rect(legendx - 5,legendy-legTextHeight-cellPadding, legW+5, 2*legTextHeight+5*cellPadding, 0)
                .attr({
                    fill: value,
                    stroke: value,
                    class: 'nwsLegend',
                    zIndex: 4
                }).add();
            legendy = legendy+2*legTextHeight+5*cellPadding
        }
    });

    if(typeof AHPSjson[nwsLid].sigstages.record === 'object'){
        if(AHPSjson[nwsLid].sigstages.record.__text > maxY){
            maxY = parseInt(AHPSjson[nwsLid].sigstages.record.__text);
        }
        chart.yAxis[0].addPlotLine({
            color: '#99FFFF',
            width: 2,
            zIndex:6,
            value: AHPSjson[nwsLid].sigstages.record.__text,
            dashStyle: 'longDash',
            id : 'plotLine',
            label: {
                text: 'NWS Record Stage: '+AHPSjson[nwsLid].sigstages.record.__text+' '+AHPSjson[nwsLid].sigstages.record._units,
                align: 'center',
                style: {
                    color: 'black',
                    fontWeight: 'bold',
                }
            }
        })
    }
    if(setTicks == true){
        chart.yAxis[0].update({
            tickPositioner: function () {
                var positions = [];
                tick = Math.floor(extremes.dataMin)-2;
                if(maxY > -9999){
                    max = maxY+2;
                }else{
                    max = extremes.dataMax+2;
                }
                increment = 1;
                if((max-tick)>20) increment = 2;
                for (tick; tick - increment <= max; tick += increment) {
                    positions.push(tick);
                }
                return positions
            }
        });
    }
}



function addNWSRender(graphId){
    $(".nwsRender").remove();
    var chart = $('#'+graphId).highcharts();
    nowP = chart.xAxis[0].toPixels(new Date().getTime())
    extX = chart.xAxis[0].getExtremes();
    extY = chart.yAxis[0].getExtremes();
    xmaxP = chart.xAxis[0].toPixels(extX.max);
    xminP = chart.xAxis[0].toPixels(extX.min);
    ymaxP = chart.yAxis[0].toPixels(extY.max);

    if(nowP>xmaxP) nowP = xmaxP;
    if(nowP<xminP) nowP = xminP;




    if(nowP > xminP){
         chart.renderer.path(['M', xminP+10, ymaxP-20, 'L', nowP-10, ymaxP-20])
            .attr({
                'stroke-width': 3,
                stroke: 'grey',
                class: 'nwsRender',
                zIndex: 3
            }).add();
        textBox = chart.renderer.label('Observed', ((nowP+xminP)/2),ymaxP-30)
            .attr({
                fill: 'white',
                padding: 1,
                zIndex: 4,
                class: 'nwsRender',
                align: 'center'
             }).css({
                    color: 'grey',
                    fontSize: '16px'
                })
             .add();
    }

    if(nowP < xmaxP){
         chart.renderer.path(['M',nowP+10,ymaxP-20,'L',xmaxP-10,ymaxP-20])
            .attr({
                'stroke-width': 3,
                stroke: 'blue',
                class: 'nwsRender',
                zIndex: 3
            }).add()
        textBox = chart.renderer.label('Forecast', ((nowP+xmaxP)/2),ymaxP-30)
            .attr({
                fill: 'white',
                padding: 1,
                zIndex: 4,
                class: 'nwsRender',
                align: 'center'
             }).css({
                    color: 'blue',
                    fontSize: '16px'
                })
             .add();
    }

    var point;

    try{
        point = chart.get('nwsObserved').data[chart.get('nwsObserved').data.length-1];
        text = chart.renderer.text(
            'Current Level: '+point.y+' ft',
            point.plotX + chart.plotLeft - 130,
            point.plotY + chart.plotTop - 15
            ).css({
            fontSize: '12px',
            fontWeight: 'bold'
            }).attr({
            zIndex: 10,
            class: 'nwsRender'
        }).add();
        text = chart.renderer.text(
            'Latest Observed Value: '+point.y+' ft at '+Highcharts.dateFormat('%l %P %b %e',point.x),
            chart.plotLeft+10,
            chart.plotTop+15
            ).attr({
                zIndex: 10,
                class: 'nwsRender'
            }).css({
                color: 'black',
                width:  '550px',
                fontSize: '12px'
            }).add();
        box = text.getBBox();
        chart.renderer.rect(box.x - 5, box.y - 1, box.width + 10, box.height + 1, 5)
           .attr({
               fill: 'white',
               stroke: 'rgba(255,255,0,1)',
               zIndex: 9,
               class: 'nwsRender'
           }).add();

    }
    catch(e){
    }
}



// Proof of concept for AJAX usage with instantaneous values service
$('#showFloodStages').change(function() {
    $(".nwsRender").remove();
    var chart = $('#stagegraph').highcharts();
    nwsLid = chart.NWSid;

    if($(this).is(':checked')){
        addNWSBands('stagegraph',AHPSjson,true,'band',true);
    }else{
        $(".nwsLegend").remove();
        $("#removeLegend").attr('value', 'Add Flood Stages');
        chart.yAxis[0].removePlotBand('plotBand');
        chart.yAxis[0].removePlotLine('plotLine');
        extremes = chart.yAxis[0].getExtremes();

        chart.yAxis[0].update({
            tickPositioner: function () {
                var positions = []
                tick = Math.floor(extremes.dataMin)-2
                max = extremes.dataMax+2
                increment = 1
                if((max-tick)>20) increment = 2
                for (tick; tick - increment <= max; tick += increment) {
                    positions.push(tick);
                }
                return positions
            }
        });
    }
   // addNWSRender('stagegraph');
});

$('#showFloodStagesRating').change(function() {
    var chart = $('#ratinggraph').highcharts();
        nwsLid = chart.NWSid;

        if($(this).is(':checked')){
            addNWSBands('ratinggraph',AHPSjson,false,'line',false);
        }else{
            chart.yAxis[0].removePlotLine('plotLine');
        }
});

$(":input[name= 'markerHighlights']").on('change', function(){
    var mType = $("input[name='markerHighlights']:checked").val();
    var chart = $('#ratinggraph').highcharts();
    var series = chart.get('qMeasured');
    if(mType == 'quality'){
        $.each(series.data, function(i, point) {
            if(typeof(point.graphic) == 'undefined') return true;
            point.graphic.attr({
                fill: this.qColor
            });
        });
        $.each(series.userOptions.originalData,function(){
            this.color =  this.qColor;
        });
     }
     else{
        $.each(series.data, function(i, point) {
            if(typeof(point.graphic) == 'undefined') return true;
            point.graphic.attr({
                fill: this.aColor
            });
        });
        $.each(series.userOptions.originalData,function(){
            this.color =  this.aColor;
        });

    }


    var htmlText = '<span style="color:red">Most Recent Measurement</span><br><span style="color:orange">Measurements in the Last Year</span><br><span style="color:rgba(0,0,205,0.8)">Newer -</span><span style="color:rgba(0,0,205,0.3)"> Older Measurements</span>';

    if(mType == 'quality'){
        htmlText = '<span style="color:Green">Excellent - Good</span><br><span style="color:#E7F317">Fair</span><br><span style="color:orange")">Poor</span>';
    }


    $(".Qnotes").remove();

    text = chart.renderer.text(
        htmlText,
        550,
        400
    ).attr({
        zIndex: 5,
        class: 'Qnotes'
    }).css({
        color: 'black',
        'text-align': 'center',
        'font-weight': 'bold',
        width:  400,
        fontSize: '13px'
    }).add();
    box = text.getBBox();
    chart.renderer.rect(box.x - 5, box.y - 5, box.width + 10, box.height + 10, 5)
        .attr({
            fill: 'white',
            stroke: 'gray',
            class: 'Qnotes',
            'stroke-width': 1,
            zIndex: 4
        })
        .add();
    //addMeasureQ_Rating('ratinggraph',chart.USGSid,"curve",$("input[name='markerHighlights']:checked").val());


});


function swapAxis(allSeries){
        var tempX;
        $.each(allSeries, function(){
            var swappedData = [];
            var object = false;
            $.each(this.data, function(){
                if($.isArray(this)){
                    swappedData.push([this[1],this[0]]);
                }else{
                    object = true;
                    tempX = this.x;
                    this.x = this.y;
                    this.y = tempX;
                    swappedData.push(this);
                }
            });

            if(object){
                swappedData.sort(function(a, b) {
                    return parseFloat(a.x) - parseFloat(b.x);
                });
            }
            this.data = swappedData;
        });
        return allSeries;
}

function plotHeatQ(usgsSite){
    var chart = $('#heatMapQ').highcharts();
    var annualChart = $('#annualMapQ').highcharts();
    if(usgsSite === undefined) return;
    $.ajax({
        url: "https://waterservices.usgs.gov/nwis/dv/?format=json,1.1&indent=on&sites=" + usgsSite + "&parameterCd=00060&startDT=1800-01-01&endDT=2100-01-19",
        dataType: 'json',
        data: '',
        success: function(json){
            var series = [];
            var heatData = USGSDailytoHCHeat(json,"00060");
            if(heatData == null){
                    var url = "https://waterservices.usgs.gov/nwis/dv/?format=json,1.1&indent=on&sites=" + usgsSite + "&parameterCd=00060&startDT=1800-01-01&endDT=2100-01-19";
                    $('<span style="color:orange">No USGS Daily Data </span><a href='+url+' target="_blank">USGS Link</a><br>').prependTo( "#log" );
                    return;
                };
            if(json.value.timeSeries.length>0){
                series.push({
                    data: heatData,
                    name:'USGS Daily Data',
                    //borderWidth: 0,
                    zIndex:2,
                    nwsType: 'observed',
                    turboThreshold: Number.MAX_VALUE // #3404, remove after 4.0.5 release
                    });

                chart.addSeries(series[0]);
            };
            var annualSeries= [{
                data: [],
                borderWidth: 0,
                nullColor: '#EFEFEF',
                turboThreshold: Number.MAX_VALUE // #3404, remove after 4.0.5 release
            }]
            for(var i = 0;i < series[0].data.length; i++) {
                if(series[0].data[i][0]>370){
                    annualSeries[0].data.push(series[0].data[i]);
                }
            }
            annualChart.addSeries(annualSeries[0]);

        },
        error : function(XMLHttpRequest, textStatus, errorThrown) {
            $('#discharge').val('');
            $('#date').val('');
        }
    });

}

function addNWMPlots(graphID,direction){
    var chart = $(graphID).highcharts();
    var nwmReach = chart.get("NWMshort").userOptions.nwmJSON;
    var x,y;
    if(direction == 'down'){
        var length = nwmReach.geometry.paths[0].length - 1
        x = nwmReach.geometry.paths[0][length][0];
        y = nwmReach.geometry.paths[0][length][1];
    }
    else if(direction == 'up'){
        x = nwmReach.geometry.paths[0][0][0];
        y = nwmReach.geometry.paths[0][0][1];
    }
    chart.get('NWMshort').remove();
    chart.get('NWMmedium').remove();
    chart.get('NWMlong').remove();
    addNWM('dischargegraph',y,x,'short_range',direction);
    addNWM('dischargegraph',y,x,'medium_range',direction);
    addNWM('dischargegraph',y,x,'long_range',direction);
}





$('#query').click(function() {
    loadPage($('#site').val());
});

$('#nwmUp').click(function() {
    addNWMPlots("#dischargegraph","up");
    $(document).ajaxStop(function () {
      addNWM2Stage('#dischargegraph','#stagegraph');
    });

});

$('#nwmDown').click(function() {
    addNWMPlots("#dischargegraph","down");
    $(document).ajaxStop(function () {
      addNWM2Stage('#dischargegraph','#stagegraph');
    });

});





$('#togglePeakLabels').click(function(){
    // Toggle data labels
    var chart = $('#dischargegraph').highcharts();
    series = chart.get('annualPeakYear');
    var opt = series.options;
    var newOption = !opt.dataLabels.enabled;

    series.update({
        dataLabels: {
            enabled: newOption
            }
    });
    series = chart.get('annualPeaks');
    var opt = series.options;
    var newOption = !opt.dataLabels.enabled;

    series.update({
        dataLabels: {
            enabled: newOption
            }
    });
});


$('#addFFlinesStation').change(function() {
  if($(this).is(':checked')){
        addUSGSFF('dischargegraph','sta');
    }
    else
    {
      $('#dischargegraph').highcharts().yAxis[0].removePlotBand('fflinesta');
  }
});

$('#addFFlinesWeighted').change(function() {
  if($(this).is(':checked')){
        addUSGSFF('dischargegraph','wtd');
    }
    else
    {
      $('#dischargegraph').highcharts().yAxis[0].removePlotBand('fflinewtd');
  }
});





$('#getGDLhydro').click(function(){

    var dischargeChart = $('#dischargegraph').highcharts();
    if(chart.get('peakHydroGraph')) chart.get('peakHydroGraph').remove();
    var base = dischargeChart.get('baseFlow');
    var compareHydro = dischargeChart.get(base.userOptions.peakDataId);
    getPeakHydroGraph(dischargeChart,compareHydro,base);
});






$('#zoomToStage').click(function(){
    var dischargeChart = $('#dischargegraph').highcharts();
    if(dischargeChart.get('dailyStats')) dischargeChart.get('dailyStats').hide();
    if(dischargeChart.get('annualPeakYear')) dischargeChart.get('annualPeakYear').hide();
    dischargeChart.xAxis[0].setExtremes(new Date().getTime()-3600000*24*7, new Date().getTime()+3600000*24*4);
    dischargeChart.showResetZoom();
});

$('#shefEncodeForecast').click(function(){
    var chart = $('#stagegraph').highcharts();
    var forecastSeries = chart.get('nwsStageForecast');

    $('#shefText').html(shefEncode(forecastSeries).replace(/(?:\r\n|\r|\n)/g, '<br />'));
});

$('#shefEncodeObserved').click(function(){
    var chart = $('#stagegraph').highcharts();
    var forecastSeries = chart.get('nwsStageObserved');

    $('#shefText').html(shefEncode(forecastSeries,true).replace(/(?:\r\n|\r|\n)/g, '<br />'));
});

$('#loadQ').click(function(){

    var chart = $('#dischargegraph').highcharts();
    var nwsLid = chart.options.nwsLid;
    var usgsID = chart.options.usgsID;
    chart.destroy;
    graphDischarge('dischargegraph',Date.parse($('#dischargeStart').val()),Date.parse($('#dischargeEnd').val()),usgsID,nwsLid);
    addStats('dischargegraph');
    if(document.getElementById('getIv').checked) addUSGS('dischargegraph','discharge','iv');
    if(document.getElementById('getDv').checked) addUSGS('dischargegraph','discharge','dv');
    addAHPS('dischargegraph','discharge');
    addAnnualPeaks('dischargegraph');

    addMeasureQ_Rating('dischargegraph',null,"series");
    if($('#addFFlinesStation').is(':checked')){
        addUSGSFF('dischargegraph','sta');
    }
    if($('#addFFlinesWeighted').is(':checked')){
        addUSGSFF('dischargegraph','wtd');
    }

});

function getBothIds(site){
    var nwsLid = '';
    var usgsID = '';
    if(site.length<=5){
        nwsLid = site.toLowerCase();
        usgsID = CROSSWALKTABLE[nwsLid];
    }
    else{
        usgsID = site;
         $.each(CROSSWALKTABLE,function(key,value){
            if(value == usgsID){
                nwsLid = key;
                return false;
            }
         });
    }
    if (typeof usgsID == 'undefined') usgsID = '';
    return {
        nws:nwsLid,
        usgs:usgsID
        }
}

function isInteger(x) {
        return x % 1 === 0;
    }

$('#loadComparison').click(function(){

    var arr = $('#comparisonSite').val().split("-");
    var year = 0;
    var site;
    $.each(arr, function( index, value ) {
        if(isInteger(value)){
             year = value;
        }
        else{
            site = getBothIds(value);
        }
    });

    if (year > 0){
        addAnnualData('dischargegraph','iv',year,site);
        addAnnualData('dischargegraph','dv',year,site);
    }
    else{
        if(document.getElementById('getIv').checked) addUSGS('dischargegraph','discharge','iv',site);
        if(document.getElementById('getDv').checked) addUSGS('dischargegraph','discharge','dv',site);
    }
});


var Area = 0;

function loadPage(site){


    var year = new Date().getFullYear();
    $('#dischargeStart').val(year+'-01-01');
    $('#dischargeEnd').val(year+'-12-31');
    //initializeNWS();
    var siteId = getBothIds(site);
    var siteInfo = {'dec_long_va': 0,
                     'dec_lat_va':0};

    //Set up empty graphs
    graphRating('ratinggraph',siteId.usgs,siteId.nws);
    graphStage('stagegraph',new Date().getTime()-3600000*24*7,new Date().getTime()+3600000*24*4,siteId.usgs,siteId.nws);
    graphDischarge('dischargegraph',Date.parse($('#dischargeStart').val()),Date.parse($('#dischargeEnd').val()),siteId.usgs,siteId.nws);
    graphHeatQ();
    annualHeatQ();
    graphAnnualPeaks();

    if($('#addFFlinesStation').is(':checked')){
        addUSGSFF('dischargegraph','sta');
    }
    if($('#addFFlinesWeighted').is(':checked')){
        addUSGSFF('dischargegraph','wtd');
    }





    //Load USGS Site Information
    if(siteId.usgs != ''){
        $.ajax({
            url: "https://waterservices.usgs.gov/nwis/site/?format=rdb,1.0&sites="+siteId.usgs+"&siteOutput=expanded",
            dataType: 'text',
            data: '',
            success: function(data){

                addStats('dischargegraph');
                addUSGSrating('ratinggraph',siteId.usgs);
                addUSGS('stagegraph','stage','iv');
                if(document.getElementById('getIv').checked) addUSGS('dischargegraph','discharge','iv');
                if(document.getElementById('getDv').checked) addUSGS('dischargegraph','discharge','dv');
                addAnnualPeaks('dischargegraph');
                addMeasureQ_Rating('dischargegraph',null,"series");
                siteInfo = getRDBSiteInfo(data);
                console.log(siteInfo);
                setupMap(siteInfo);
                var reachID = addNWM('dischargegraph',siteInfo['dec_lat_va'],siteInfo['dec_long_va'],'short_range','down');
                addNWM('dischargegraph',siteInfo['dec_lat_va'],siteInfo['dec_long_va'],'medium_range','down',reachID);
                addNWM('dischargegraph',siteInfo['dec_lat_va'],siteInfo['dec_long_va'],'long_range','down',reachID);
                showUSGSinfo(siteInfo);
                Area = siteInfo.drain_area_va;
                Highcharts.setOptions({
                    title: {
                        text:siteInfo.station_nm
                    }
                });
            },
        });
     }
     else{
        $.ajax({
                url: "http://www.data.chenabasin.org/nws/streamGraph/get_ahps_data.php?format=rss&site="+site,
                dataType: 'text',
                data: '',
                async: false,
                success: function(xml){
                    var myRe = /<geo:long>(.*)<\/geo:long>/g;
                    var myArray = myRe.exec(xml);
                    siteInfo['dec_long_va'] = parseFloat(myArray[1]);
                    myRe = /<geo:lat>(.*)<\/geo:lat>/g;
                    myArray = myRe.exec(xml);
                    siteInfo['dec_lat_va'] = parseFloat(myArray[1]);
                    setupMap(siteInfo);
                    var reachID = addNWM('dischargegraph',siteInfo['dec_lat_va'],siteInfo['dec_long_va'],'short_range','down');
                    addNWM('dischargegraph',siteInfo['dec_lat_va'],siteInfo['dec_long_va'],'medium_range','down',reachID);
                    addNWM('dischargegraph',siteInfo['dec_lat_va'],siteInfo['dec_long_va'],'long_range','down',reachID);

                }
        });
    }

    //Setup Stage and Discharge Graphs with AHPS data
    if(siteId.nws != ''){
        addAHPS('dischargegraph','discharge');
        addAHPS('stagegraph','stage');
        if($('#showFloodStages').is(':checked')){
            addNWSBands('stagegraph',AHPSjson,true,'band',true);
        }

        if($('#showFloodStagesRating').is(':checked')){
            addNWSBands('ratinggraph',AHPSjson,false,'line',false);
        }

        addAHPSrating('ratinggraph',siteId.nws);
    }

    $(document).ajaxStop(function () {
        addNWM2Stage('#dischargegraph','#stagegraph');
    });

    if(siteId.usgs != '') plotHeatQ(siteId.usgs);



}

function setupMap(siteInfo){
    var usgsLat = parseFloat(siteInfo.dec_lat_va);
    var usgsLon = parseFloat(siteInfo.dec_long_va);

    map.getView().setCenter(ol.proj.transform([usgsLon, usgsLat], 'EPSG:4326', 'EPSG:3857'));
    var iconFeature = new ol.Feature({
        geometry: new ol.geom.Point(ol.proj.transform([usgsLon, usgsLat], 'EPSG:4326', 'EPSG:3857')),
    });
    var fill = new ol.style.Fill({
        color: 'rgba(255,51,255,0.4)'
    });
    var stroke = new ol.style.Stroke({
        color: '#FF0000',
        width: 1.25
    });
    var styles = [
        new ol.style.Style({
            image: new ol.style.Circle({
                fill: fill,
                stroke: stroke,
                radius: 7
            }),
            fill: fill,
            stroke: stroke
        })
    ];

    iconFeature.setStyle(styles);
    var vSource = new ol.source.Vector({
        features: [iconFeature]
    });

    var vLayer = new ol.layer.Vector({
        source: vSource
    });
    map.addLayer(vLayer);
}

function graphStage(container,minDate,maxDate,usgs,nws){

    var title;
    stagechartobj= {
        usgsID:usgs,
        nwsLid:nws,
        credits: {
            enabled: false
        },
        chart: {
            renderTo: container,
            zoomType: 'xy',
            marginTop: 80,
            marginBottom:175,
            marginLeft:80,
            events: {
                selection: selectPointsByDrag,
                redraw: function(){
                    addNWSRender(this.options.chart.renderTo);
                }

            },
        },

        xAxis: {
            max : maxDate,
            min : minDate,
            type: 'datetime',
            tickPixelInterval: 25,
            gridLineColor: "#E8E8E8",
            gridLineWidth: 1,
            labels: {
                step: 2,
                staggerLines: 1,
                formatter: function () {
                    return Highcharts.dateFormat('%l %P<br>%b %e',this.value)
                }
            },
            plotLines: [{
                color: 'black', // Color value
                dashStyle: 'dot', // Style of the plot line. Default to solid
                value: new Date().getTime(), // Value of where the line will appear
                width: '2', // Width of the line
                zIndex:4
            }],
            plotBands: [{
                from: 0,
                to: new Date().getTime(),
                color: 'rgba(248,248,248,0.4)',
                zIndex:2,
                id: 'plot-band-observed'
            }]
        },
        yAxis: [{
            allowDecimals: false,
            title: {
                text: 'River Stage (ft)',
                style: {
                    color: 'Black',
                    fontWeight: 'bold',
                    fontSize: '14px'
                }
            },
            labels:{
                x: -5
            },

        }],
        tooltip: {
            valueSuffix: ' ft',
            shared: false,
            zIndex: 11,
            //headerFormat: '<span style="font-size: 14px">'+moment({point.key})format('MMM D, YYYY HH:mm')+'</span><br/>',
            headerFormat: '<span style="font-size: 12px;font-weight: bold;">{point.key:%Y-%m-%d %H:%M}</span><br/>',
            positioner: function () {
                    return { x: 375, y: 350 };
             },

        },
        plotOptions:{
            series:{
                stickyTracking : false,
                turboThreshold: 0,
                point:{
                    events:{
                        drop:function(){
                            var ratingchart = $('#ratinggraph').highcharts();
                            var dischargeChart = $('#dischargegraph').highcharts();
                            if(typeof(ratingchart.get('curve')) != 'undefined'){
                                cData = ratingchart.get('curve').data;
                            }
                            else if(typeof(ratingchart.get('nwsCurve')) != 'undefined'){
                                cData = ratingchart.get('nwsCurve').data;
                            }else{
                                return;
                            }

                            this.update({y:round(this.y,2)});
                            if(this.series.options.id == 'nwsStageForecast' && dischargeChart.get('nwsDischargeForecast') != null){
                                var forecast = dischargeChart.get('nwsDischargeForecast').points;
                                    var newY = this.y;
                                    var newDischarge = parseInt(curveLookup(cData,newY,'stage'));
                                    for (var i = 0; i < forecast.length; i++) {
                                        if (forecast[i].x == this.x){
                                            forecast[i].update({y:parseInt(newDischarge)});
                                            break;
                                        }
                                    }
                                //}
                            }

                            var extremes = this.series.yAxis.getExtremes();
                            var max = extremes.max;
                            var min = extremes.min;
                            if(extremes.dataMax > extremes.max-2) max = extremes.max + 4;
                            if(extremes.dataMin < extremes.min+2) min = extremes.min - 4;

                            var chart = this.series.chart;
                            var positions = chart.yAxis[0].tickPositions;
                            var interval = positions[1]-positions[0];
                            if(extremes.dataMax > extremes.max-3){
                                var last = positions[positions.length-1];
                                positions.push(last+interval,last+interval*2,last+interval*3);
                            }
                            chart.yAxis[0].update({
                                tickPositioner: function () {
                                    var positions = [];
                                    var tick = Math.floor(min);
                                    increment = 1;
                                    if((max-tick)>20) increment = 2;
                                    for (tick; tick - increment < max; tick += increment) {
                                        positions.push(tick);
                                    }
                                    return positions
                                }
                            });
                       }
                    }
                 }
            }
        },
        legend: {
            align: 'center',
            verticalAlign: 'bottom',
            borderWidth: 0,
            y:-100,
            x:25
        },
        series : [{data:[null,null],
                    showInLegend:false}]

    }
  chart = new Highcharts.Chart(stagechartobj);
}

function graphAnnualPeaks(){
    annualPeakchartobj = {
        credits: {
            enabled: false
        },
       chart: {
            renderTo: 'annualPeakGraph',
            zoomType: 'x',
            marginTop: 5,
            marginLeft:70,

        },
        title:{
            text: 'Annual Peaks'
        },
        xAxis: {
            title: {
                text: 'Year'
            },
            type: 'datetime',
            tickInterval: 5 * 365 * 24 * 36e5, // one week
            labels: {
                format: '{value:%Y}',
                align: 'right',
                rotation: -30
        }
        },
        yAxis: {
            title: {
                text: 'Peak Annual Discharge (cfs)'
            }
        },
        legend: {
            enabled : false
        },

        series : [{data:[null,null],
                    visible:false,
                    showInLegend:false}]
    }

    new Highcharts.Chart(annualPeakchartobj);
  }


function graphDischarge(container,minDate,maxDate,usgs,nws){
    ////////////////////////////////////Discharge Graph////////////////////////////////
    var first_line = true;
    var shift;
    var shiftIndex;
    var xMin;
    var xMax;


    dischargechartobj= {
        credits: {
            enabled: false
        },
        usgsID: usgs,
        nwsLid:nws,
        chart: {
            renderTo: container,
            zoomType: 'xy',
            marginTop: 40,
            //marginBottom:100,
            marginLeft:80,
        },
        plotOptions:{
            series:{
                stickyTracking : false,
                turboThreshold: 0,
                point: {
                    events: {
                        click: function() {
                            chart = this.series.chart;
                            if($("input[name=Qfunction]:checked").val() == 'base'){
                                if(this.series.userOptions.calcVol  == true){
                                    if(first_line){
                                        $(".baseFlowLabel").remove();
                                        if(chart.get('baseFlow')) chart.get('baseFlow').remove();
                                        xMin = this.x;
                                        first_line = false;
                                        chart.xAxis[0].addPlotLine({
                                            value: this.x,
                                            color: 'red',
                                            width: 1,
                                            id: 'vert_1',
                                            zIndex:5
                                        });
                                    }
                                    else{
                                        first_line = true;
                                        if(chart.get('baseFlow')) chart.get('baseFlow').remove();
                                        chart.xAxis[0].removePlotLine('vert_1');
                                        xMax = this.x;
                                        series = this.series;
                                        addBaseFlowSeries(chart,series,xMin,xMax);
                                        handleBaseFlow(chart,series,xMin,xMax);

                                    }
                                }

                            }
                            else if($("input[name=Qfunction]:checked").val() == 'shift'){
                                if(first_line){
                                    shift = this.x;
                                    first_line = false;
                                    shiftIndex = this.series.index;

                                }
                                else{
                                    first_line = true;
                                    var shiftData = [];
                                    shift = this.x - shift;
                                    chart.series[shiftIndex].options.dateShift = chart.series[shiftIndex].options.dateShift+shift
                                    for(i=0;i<chart.series[shiftIndex].xData.length;i++){
                                        if(typeof chart.series[shiftIndex].xData[i] == 'undefined') continue;
                                        date = chart.series[shiftIndex].xData[i]+shift;
                                        shiftData.push([date,chart.series[shiftIndex].yData[i]]);
                                    }
                               chart.series[shiftIndex].setData(shiftData);
                               }
                           }
                        },
                        mouseOver: function() {
                            var rCurve;
                            var ratingchart = $('#ratinggraph').highcharts();
                            var val;


                            if(typeof(ratingchart.get('curve')) != 'undefined'){
                                rCurve = ratingchart.get('curve');
                            }
                            else if(typeof(ratingchart.get('nwsCurve')) != 'undefined'){
                                rCurve = ratingchart.get('nwsCurve');
                            }
                            else {
                                return;
                            }

                            if(typeof this.high == 'undefined'){
                                val = this.y;
                            }else{
                                val = this.high;
                            }
                            ratingchart.xAxis[0].removePlotLine('vert_loc');
                            ratingchart.yAxis[0].removePlotLine('horz_loc');
                            ratingchart.xAxis[0].addPlotLine({
                                value: val,
                                color: 'red',
                                width: 2,
                                id: 'vert_loc',
                                zIndex:100

                            });
                            ratingchart.yAxis[0].addPlotLine({
                                value: curveLookup(rCurve.data,val),
                                color: 'red',
                                width: 2,
                                id: 'horz_loc',
                                label: {
                                    text: curveLookup(rCurve.data,val),
                                    align: 'center',
                                    style: {
                                        fontWeight: 'bold',
                                        backgroundColor: 'white'
                                    },
                                    y:-2,
                                    zIndex:100
                                }

                            });
                        },
                        mouseOut: function() {
                            var ratingchart = $('#ratinggraph').highcharts();
                            ratingchart.xAxis[0].removePlotLine('vert_loc');
                            ratingchart.yAxis[0].removePlotLine('horz_loc');
                        },
                        drop: function(){
                            var ratingchart = $('#ratinggraph').highcharts();
                            if(this.series.options.id == 'nwsDischargeForecast'){
                                var stageChart = $('#stagegraph').highcharts();
                                var forecast = stageChart.get('nwsStageForecast').points;
                                for(var y =0; y< this.series.data.length;y++){
                                    var newY = parseInt(this.series.data[y].y);
                                    var stage = curveLookup(ratingchart.get('curve').data,newY);
                                    this.series.data[y].update({y:newY});
                                    for (var i = 0; i < forecast.length; i++) {
                                        if (forecast[i].x == this.series.data[y].x){
                                            forecast[i].update({y:parseFloat(stage)});
                                            break;
                                        }
                                    }
                                }
                             }
                        }
                    }
                }
            }
       },

        xAxis: {
            max:maxDate,
            min:minDate,
            type: 'datetime',
            tickPixelInterval: 25,
            gridLineColor: "#E8E8E8",
            gridLineWidth: 1,
            labels: {
                step: 2,
                staggerLines: 1,
                formatter: function () {
                    return Highcharts.dateFormat('%l %P<br>%b %e',this.value)
                }
            },
            plotLines: [{
                color: 'black', // Color value
                dashStyle: 'dot', // Style of the plot line. Default to solid
                value: new Date().getTime(), // Value of where the line will appear
                width: '2', // Width of the line
                zIndex:2
            }],
        },
        yAxis: [{
            title: {
                text: 'River Discharge (cfs)',
                style: {
                    color: 'Black',
                    fontWeight: 'bold',
                    fontSize: '14px'
                }
            },
            labels:{
                x: -5
            },
            type: 'linear',
            floor:0

        }],
        tooltip: {
            valueSuffix: ' cfs',
            shared: false,
            crosshairs: true,
            headerFormat: '<span style="font-size: 12px;font-weight: bold;">{point.key:%Y-%m-%d %H:%M}</span><br/>',
            positioner: function () {
                    return { x: 100, y: 28 };
             }
        },
        legend: {
          align: 'center',
          verticalAlign: 'bottom',
          borderWidth: 0,
          x:10
        },
        series : [{data:[null,null],
                    visible:false,
                    showInLegend:false}]
    }

    new Highcharts.Chart(dischargechartobj);
  }




function graphRating(container,usgs,nws){
    ////////////////////////////////////Rating Graph////////////////////////////////
    ratingchartobj= {
      credits: {
          enabled: false
        },
        usgsID: usgs,
        nwsLid:nws,

        chart: {
          renderTo: container,
          zoomType: 'xy',
          marginTop: 50,
          marginBottom:100,
          marginLeft:80,
          custom:'regular',
        },
        title: {
            text: 'Stage vs. Discharge'
        },
        xAxis: {
            type: 'logarithmic',
            crosshair: {
                width: 1,
                snap:false,
                color: 'red'
            },
            type: 'linear',
            title: {
                text: 'River Discharge (cfs)',
                style: {
                    color: 'Black',
                    fontWeight: 'bold',
                    fontSize: '14px'
                }
            },
        },
        yAxis: [{
            crosshair: {
                width: 1,
                color: 'red'
            },
            title: {
                text: 'River Stage (ft)',
                style: {
                    color: 'Black',
                    fontWeight: 'bold',
                    fontSize: '14px'
                }
            },
            labels:{
                x: -5
            },
            type: 'linear'
        }],
        tooltip: {
            headerFormat: 'Rating Curve<br>',
            zIndex:10,
            positioner: function () {
                    return { x: 20, y: 20 };
                }
        },
        legend: {
            align: 'center',
            verticalAlign: 'bottom',
            borderWidth: 0,
            x:10
        },
        series : [{data:[null,null],
                    visible:false,
                    showInLegend:false}]
    }
    chart = new Highcharts.Chart(ratingchartobj);
}



$('#dischargeAxis').change(function() {
  if($(this).is(':checked')){
    $('#dischargegraph').highcharts().yAxis[0].update({ type: 'logarithmic'});
    }
    else
    {
      $('#dischargegraph').highcharts().yAxis[0].update({ type: 'linear'});
  }
});

$('#ratingLog').change(function() {
  if($(this).is(':checked')){
        $('#ratinggraph').highcharts().yAxis[0].update({ type: 'logarithmic'});
        $('#ratinggraph').highcharts().xAxis[0].update({ type: 'logarithmic'});
    }
    else
    {
        $('#ratinggraph').highcharts().yAxis[0].update({ type: 'linear'});
        $('#ratinggraph').highcharts().xAxis[0].update({ type: 'linear'});
  }
});


function graphHeatQ(){
    var ratingchart = $('#ratinggraph').highcharts();

    var title;


    var start;
    heatchartobj= {
        chart: {
            renderTo: 'heatMapQ',
            type: 'heatmap',
            zoomType: 'xy',
            marginRight: 0,
            marginTop:40,
            marginBottom:100,
            marginLeft:50

        },
        credits: {
            enabled: false
        },
        title: {
            text: 'DAILY DATA'
        },
        plotOptions:{
            series:{
                point: {
                    events: {
                        mouseOver: function() {
                            ratingchart.xAxis[0].removePlotLine('vert_loc');
                            ratingchart.yAxis[0].removePlotLine('horz_loc');
                            ratingchart.xAxis[0].addPlotLine({
                                value: this.value,
                                color: 'red',
                                width: 1,
                                id: 'vert_loc'
                            });
                            ratingchart.yAxis[0].addPlotLine({
                                value: curveLookup(ratingchart.get('curve').data,this.value),
                                color: 'red',
                                width: 1,
                                id: 'horz_loc'
                            });
                        },
                        mouseOut: function() {
                            ratingchart.xAxis[0].removePlotLine('vert_loc');
                            ratingchart.yAxis[0].removePlotLine('horz_loc');
                        }

                    }
                }
            }
       },

       xAxis: {
            title: {
                text: 'Day of Year'
            },
            min: 0,
            max: 365,
            tickPositions: [1,32, 60,91, 121,152, 182,213, 244,274,305,335,380],
            labels: {
                align: 'left',
                x: 5,
                y: 14,
                formatter: function (){
                    if(this.value == 370) return 'Annual';
                    return $.datepicker.formatDate(' M ',dateFromDay('2015',this.value));
                 }
            },
            showLastLabel: true,
            tickLength: 10
        },

        yAxis: {
            title: {
                text: 'Year'
            },
            minPadding: 0,
            maxPadding: 0,
            max:2020
        },

        colorAxis: {
            type: 'logarithmic',
            stops: [
                [0 ,   '#FF0000'],
                [0.3, '#FFCC33'],
                [0.8, '#66CCFF'],
                [1 ,   '#3300CC']
            ],
            startOnTick: false,
            endOnTick: false
        },
        tooltip: {
            headerFormat: 'Daily Discharge<br>',
            formatter: function (){
                return '<b>' + $.datepicker.formatDate('M d yy',dateFromDay(this.point.y,this.point.x))+' - '+numberWithCommas(this.point.value) + ' cfs </b>';
            },
            positioner: function () {
                    return { x: 300, y: 15 };
             }
        }
    }
    heatchart = new Highcharts.Chart(heatchartobj);
    heatchart.renderer.text('Flow (cfs)', 270, 545)
            .css({
                color: 'black',
                fontSize: '14px'
            })
            .add();

}


function annualHeatQ(){


    var start;
    annualheatchartobj= {
        chart: {
            renderTo: 'annualMapQ',
            type: 'heatmap',
            zoomType: 'xy',
            marginLeft: 0,
            marginRight: 0,
            marginTop:40,
            marginBottom:100

        },
        credits: {
            enabled: false
        },
        exporting: {
            enabled: false
        },
        title:{
            floating:true,
            text:''
        },
        legend: {
            enabled: false
        },
       xAxis: {
            min: 374,
            max: 376,
            tickPositions: [374],
            labels: {
                align: 'left',
                x: 5,
                y: 14,
                formatter: function (){
                    if(this.value == 374) return 'Annual';
                    return $.datepicker.formatDate(' M ',dateFromDay('2015',this.value));
                 }
            },
            showLastLabel: true,
            tickLength: 10
        },

        yAxis: {
            minPadding: 0,
            maxPadding: 0,
            max:2020,
            labels:{
                enabled: false
            }
        },

        colorAxis: {
            type: 'linear',
            stops: [
                [0 ,   '#FF0000'],
                [0.3, '#FFCC33'],
                [0.8, '#66CCFF'],
                [1 ,   '#3300CC']
            ],
            startOnTick: false,
            endOnTick: false,
        },
        tooltip: {
            formatter: function (){
                if(this.point.value == null) return 'No Avg.<br>Available';
                return '<b>Avg.<br>' + this.point.y +'<br>'+numberWithCommas(parseInt(this.point.value)) + ' cfs </b>';
            },
            positioner: function () {
                    return { x: 0, y: 0 };
             }
        },


    }


    annualheatchart = new Highcharts.Chart(annualheatchartobj);

}



    /**
     * Display a temporary label on the chart
     */
    function toast(chart, text) {
        chart.toast = chart.renderer.label(text, 100, 120)
            .attr({
                fill: Highcharts.getOptions().colors[0],
                padding: 10,
                r: 5,
                zIndex: 8
            })
            .css({
                color: '#FFFFFF'
            })
            .add();

        setTimeout(function () {
            chart.toast.fadeOut();
        }, 2000);
        setTimeout(function () {
            chart.toast = chart.toast.destroy();
        }, 2500);
    }

    /**
     * Custom selection handler that selects points and cancels the default zoom behaviour
     */
    function selectPointsByDrag(e) {
        if($("input[name=stageDrag]:checked").val() == 'zoom'){
            return true;
        }

        // Select points
        Highcharts.each(this.series, function (series) {
            Highcharts.each(series.points, function (point) {
                if (point.x >= e.xAxis[0].min && point.x <= e.xAxis[0].max &&
                        point.y >= e.yAxis[0].min && point.y <= e.yAxis[0].max) {
                    //point.select(true, true);
                    if (point.series.visible === true) point.update([point.x,null]);

                }
            });
        });

        // Fire a custom event
       // Highcharts.fireEvent(this, 'selectedpoints', { points: this.getSelectedPoints() });
        chart.redraw();
        return false; // Don't zoom
    }

    /**
     * The handler for a custom event, fired from selection event
     */
    function selectedPoints(e) {
        // Show a label
        toast(this, '<b>' + e.points.length + ' points selected.</b>' +
            '<br>Click on empty space to deselect.');
    }

    /**
     * On click, unselect all points
     */
    function unselectByClick() {
        var points = this.getSelectedPoints();
        if (points.length > 0) {
            Highcharts.each(points, function (point) {
                point.select(false);
            });
        }
    }



$(function () {

    var d = new Date()
    var n = d.getTimezoneOffset()/60;

    $( "#map" ).resizable({
        aspectRatio: true
    });

    Highcharts.setOptions({
        title: {
                text:'test'
        },
        global: {
            //useUTC: false,
            timezoneOffset: n * 60

        },
        lang: {
            thousandsSep: ','
         },
         tooltip: {
            backgroundColor : 'rgba(255, 255, 255, 1)',
         }

    });

    $('#dischargeStart').val(Highcharts.dateFormat('%Y-%m-%d',new Date().getTime()-3600000*24*30));
    $('#dischargeEnd').val(Highcharts.dateFormat('%Y-%m-%d',new Date().getTime()+3600000*24*4));

    site = getParameterByName('site');
    $('#site').val(site);

    //Load USGS to NWSLID Cross Walk Table
    $.ajax({
        type: 'GET',
          url: 'crossWalk.json',
          dataType: 'json',
          success: function(data) {
            CROSSWALKTABLE = data;
            },
          async: false,
          error : function(XMLHttpRequest, textStatus, errorThrown) {
                alert('error getting crosswalk table');

            }
    });


    if(site != null){
        loadPage(site);
    }
    $(document).keydown(function(e) {

        var hours = 24;
        var shift = false;
        if(e.keyCode == 40 && e.shiftKey){
            addNWMPlots("#dischargegraph","down")
        }
        if(e.keyCode == 38 && e.shiftKey){
            addNWMPlots("#dischargegraph","up")

        }

        if(e.keyCode == 39 && e.shiftKey){
            e.preventDefault();
            hours = 24
            if(e.ctrlKey) hours = 1
            shift = true;
        }
        if(e.keyCode == 37 && e.shiftKey){
            e.preventDefault();
            hours = -24
            if(e.ctrlKey) hours = -1
            shift = true;
        }
        if(shift){
            var chart = $('#dischargegraph').highcharts();

            var length=chart.series.length
            for (var z = 0; z < length; z++){
                if(chart.series[z].options.timeShift != true) continue;
                if(chart.series[z].visible != true) continue;
                series = chart.series[z];
                series.options.dateShift = series.options.dateShift-(hours*3600*1000)
                var xData = series.xData;
                var yData = series.yData;
                var shiftData = [];
                for(i=0;i<xData.length;i++){
                    if(typeof xData[i] == 'undefined') continue;
                    date = moment(xData[i]).add(hours, 'hours');
                    shiftData.push([date.valueOf(),yData[i]]);
                }
                series.setData(shiftData);
            }
        }
    });

    $( "#qmeas-range" ).dragslider({
        range: true,
        min: 0,
        max: 11,
        step: 1,
        values: [0,11],
        rangeDrag: true, // Enable range dragging.
        slide: function( event, ui ) {
            $( "#months2show" ).val( moment(new Date(2012, ui.values[0], 01)).format("MMM")+ " - " + moment(new Date(2012, ui.values[1], 01)).format("MMM") );
            showQmeas((ui.values[0]+1),(ui.values[1]+1),$("#qmeas-years" ).dragslider( "values", 0 ),$("#qmeas-years" ).dragslider( "values", 1 ));
        },
        stop: function( event, ui ) {
            $( "#months2show" ).val( moment(new Date(2012, ui.values[0], 01)).format("MMM")+ " - " + moment(new Date(2012, ui.values[1], 01)).format("MMM") );
            showQmeas((ui.values[0]+1),(ui.values[1]+1),$("#qmeas-years" ).dragslider( "values", 0 ),$("#qmeas-years" ).dragslider( "values", 1 ));
        }
    });
    $( "#months2show" ).val( moment(new Date(2012,$( "#qmeas-range" ).dragslider( "values", 0 ), 01)).format("MMM") +
      " - " + moment(new Date(2012,$( "#qmeas-range" ).dragslider( "values", 1 ), 01)).format("MMM") );



});



</script>

</html>

